----------------------------------------------------------------------------------------------------------------------
--  Схема встречи двух сталкеров
--  автор: Диденко Руслан (Stohe)
--  TODO:
----------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
--' Возвращает есть ли у нас контакт с другим сталкером
class "evaluator_contact" (property_evaluator)
function evaluator_contact:__init(name, storage) super (nil, name) counterAdd("xr_meet.evaluator_contact:__init")
  self.a = storage
  self.a.scan_time = time_global()
end
function evaluator_contact:evaluate() counterAdd("xr_meet.evaluator_contact:evaluate")
	if self.a.meet_set ~= true then return false end
	if db.actor then
		if has_alife_info("invizible_actor") then
			self.object:disable_talk()
			self.begtime = nil
			return false
		end
		if not db.actor:alive() then return false end
		if xr_wounded.is_wounded(self.object) then	-- Red75 +
			self.begtime=nil
			return false
		end
        
        local tg = time_global()
        if tg > self.a.scan_time then
          self.a.meet_manager:update()
          self.a.scan_time = tg + 500
        end
        
		if self.mgr == nil then self.mgr = self.object:motivation_action_manager() end
		if self.object:relation(db.actor) ~= game_object.friend and
          (
            self.mgr:evaluator(stalker_ids.property_enemy):evaluate()
            or
            self.mgr:evaluator(stalker_ids.property_danger):evaluate()
          )
        then
			self.object:disable_talk()
			self.begtime = nil
			return false
		end
		-- Чтобы не стояли и не пялились часами
		local tken = (self.a.meet_manager.state ~= "nil")
		local istk=self.object:is_talking()
		if self.begtime == nil and tken then self.begtime = time_global()
		elseif not tken then self.begtime = nil
		elseif tken and self.begtime+6000 < time_global() and (not istk)
		  and (not self.a.meet_manager.wpn_meet) then return false	-- 6 (dc, was:10) секунд посмотрели на меченного и хватит
		elseif istk or self.a.meet_manager.wpn_meet then self.begtime = time_global()
		end
		return self.a.meet_manager.state ~= "nil"	-- Red75 -
	else return false
	end
end

----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
--' Приглашение к тороговле
class "action_meet_wait" (action_base)
function action_meet_wait:__init (npc_name,action_name, storage, char_ini) super (nil, action_name) counterAdd("xr_meet.action_meet_wait:__init")
--amk.send_tip("отлавливаем 1", "ЛОВИМ", 0, 15, "common_channel")
  self.char_ini = char_ini
  self.a = storage
end
local tbl_npc = {""}

function antispam(npc)
local state
	local function check(npc)
		for i=1, #tbl_npc do
			if  string.find(tbl_npc[i],npc:id()) then 
--				amk.send_tip("с ним уже здоровались", "ДА", 0, 15, "common_channel")
				return true
			end
		end
	end
		if not check(npc) then 
--			amk.send_tip("заносим в таблицу НПС с ИД: "..npc:id(), "ИНФО", 0, 15, "common_channel")
			table.insert(tbl_npc,npc:id())
			state = 1
			return true
		end 
end

function action_meet_wait:initialize()
local state
  action_base.initialize(self)
--  self.object:set_node_evaluator()
--  self.object:set_path_evaluator()
  self.object:set_desired_position()
  self.object:set_desired_direction()
  -- кешируемые данные
  self.sound = "nil"
  -- Здороваемся.
  if self.a.init_meet ~= "" and antispam(self.object) then
--  amk.send_tip("123","123",0,15,"common_channel")
    xr_sound.set_sound_play(self.object, self.a.init_meet)
  end
end
function action_meet_wait:execute () counterAdd("xr_meet.action_meet_wait:execute")
  action_base.execute(self)
  local meet_manager = self.a.meet_manager

  local victim = nil
  if meet_manager.victim == "actor" then
    victim = db.actor
  elseif meet_manager.victim == "nil" then
    victim = nil
  else
    local sim = alife()
    if sim then
      victim = sim:story_object(victim)
    end
  end

  local synsound = nil
  if meet_manager.state == "true" then
    local h = hit()
    h.power = 0
    h.direction = self.object:direction()
    h.bone = "bip01_spine"
    h.draftsman = db.actor
    h.impulse = 0
    h.type = hit.wound
    self.object:hit(h)
    sol_utils.setRelation(self.object, game_object.enemy, db.actor)
  else
    -- является ли текущий звук синхронным для текущего стейта
    for k,v in pairs(self.a.syndata) do
      if v.state == meet_manager.state and
         v.sound == meet_manager.sound
      then
        synsound = meet_manager.sound
      end
    end

    if meet_manager.state~="nil" then
      if meet_manager.emerg_state == true then
        state_mgr.set_state(self.object, meet_manager.state, nil, nil, {look_object = victim}, {animation = true}, synsound)
      else
        state_mgr.set_state(self.object, meet_manager.state, nil, nil, {look_object = victim}, nil, synsound)
      end
    end
  end

  if synsound == nil then
    -- нужно отыграть фоновый
    if self.sound ~= meet_manager.sound then
      self.sound = meet_manager.sound
      if self.sound == "nil" then
        xr_sound.set_sound(self.object, nil)
      else
        local idle_timeout = 0
        if meet_manager.sound == "wait" then
          idle_timeout = 10000
        end
        xr_sound.set_sound(self.object, meet_manager.sound, nil, idle_timeout)
      end
    end
  else
    -- нужно зарубить фоновый
    if self.sound ~= nil then
      self.sound = "nil"
      xr_sound.set_sound(self.object, nil)
    end
  end

  --' Туториал на спрятать оружие
  if meet_manager.disable_talk_weapon == true and
       not has_alife_info("tutorial_part_15_hide_weapon")
  then
    --game.start_tutorial("part_15_hide_weapon")
    db.actor:give_info_portion("tutorial_part_15_hide_weapon")
  end

  local tt = db.storage[self.object:id()]
  if tt.active_scheme then
    if db.actor then
      if xr_logic.try_switch_to_another_section(self.object, tt[tt.active_scheme], db.actor) then
        return
      end
    end
  end
end
function action_meet_wait:finalize () counterAdd("xr_meet.action_meet_wait:finalize")
  action_base.finalize(self)
  xr_sound.set_sound(self.object, nil)
end

class "Cmeet_manager"
function Cmeet_manager:__init(npc, storage) counterAdd("xr_meet.Cmeet_manager:__init")
  self.npc = npc
  self.a = storage
  self.emerg_state = false
  self.startdialog = nil
end
function Cmeet_manager:update() counterAdd("xr_meet.Cmeet_manager:update")
  -- стартовый диалог
  local targets = task_manager.amk_kill_targets()
  local kill_dialog=nil
  local id = self.npc:id()
  for k,v in pairs(targets) do
    if v.id==id then
      kill_dialog=v.dialog
      break
    end
  end
  if kill_dialog then
  -- NPC собрались убивать, поэтому ничего важнее быть не может. Всё остальное потом
    if self.startdialog~=kill_dialog then
      self.npc:set_start_dialog(kill_dialog)
      self.startdialog=kill_dialog
    end
  elseif self.a.meet_dialog ~= nil then
    local tmp = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_dialog)
    if self.startdialog ~= tmp then
      self.startdialog = tmp
      if tmp == nil or tmp == "nil" then
        -- восстановление начального
        self.npc:restore_default_start_dialog()
      else
        -- установка нового
        self.npc:set_start_dialog(tmp)
      end
    end
  elseif (not kill_dialog) then
    self.npc:restore_default_start_dialog()
  end

  self:process_use()

  if self.npc:is_talking() then
    self.dist = 0
  else
    self.dist = self.npc:position():distance_to(db.actor:position())
  end

  self.victim = self:process_victim()

  self.state_zone,self.sound_zone = self:process_zone()
  if self.state_zone ~= "nil" then
    if self.victim == "nil" then
      self.victim = "actor"
    end
    self.state,self.sound = self.state_zone,self.sound_zone
  else
    self.state,self.sound = self:process_meet()
  end
  -- Если актер говорит, и говорит не с нами, то мы не должны говорить звуков.
  if db.actor:is_talking() and not self.npc:is_talking() then
    self.sound = "nil"
  end

  if self.a.precond == "usability" and not self.npc:is_talking() then
    self.state = "nil"
    self.sound = "nil"
    return
  end

  if self.a.precond == "visibility" and not self.npc:see(db.actor) and not self.npc:is_talking() then
    self.state = "nil"
    self.sound = "nil"
    return
  end
end
function Cmeet_manager:process_zone() counterAdd("xr_meet.Cmeet_manager:process_zone")
  if self.a.zone == nil then return "nil","nil" end
  local key
  key = self:get_key_from_zone(self.a.zone)
  if key ~= nil then
    local r1,r2
    if self.a.zone[key].state then
      r1 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.zone[key].state)
      self.emerg_state = true
    end
    if self.a.zone[key].sound then
      r2 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.zone[key].sound)
    end
    return tostring(r1), tostring(r2)
  end
  return "nil","nil"
end
function Cmeet_manager:process_meet() counterAdd("xr_meet.Cmeet_manager:process_meet")
  local key
  local is_talking = self.npc:is_talking()
  if db.actor:active_item() and IAmAWeapon[db.actor:active_item():clsid()] and
       self.npc:relation(db.actor) ~= game_object.friend and self:actor_targets_npc(self.npc)
    then
    key = self:get_key_from_distance(self.a.meet_state_wpn)
    if key ~= nil then
      self.wpn_meet=true
      local r1,r2
      if self.a.meet_state_wpn[key].state then
        r1 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_state_wpn[key].state)
        self.emerg_state = true
      end
      if is_talking then
        r2 = nil
      else
        if self.a.meet_state_wpn[key].sound then
          r2 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_state_wpn[key].sound)
        end
      end
      return tostring(r1), tostring(r2)
    end
  else
    self.wpn_meet=false
    key = self:get_key_from_distance(self.a.meet_state)
    if key ~= nil then
      local r1,r2
      if self.a.meet_state[key].state then
        r1 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_state[key].state)
		--'lsclon ---------------
		local back_off = {'threat','backoff'}
		if r1 then
			for i=1, #back_off do
				if string.find(r1,back_off[i],1) then
					self.wpn_meet=true
				end
			end
		end
		--'lsclon ---------------
        self.emerg_state = false
      end
      if is_talking then
        r2 = nil
      else
        if self.a.meet_state[key].sound then
          r2 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_state[key].sound)
        end
      end
      return tostring(r1), tostring(r2)
    end
  end
  return "nil","nil"
end
function Cmeet_manager:process_victim() counterAdd("xr_meet.Cmeet_manager:process_victim")
  local key
  if db.actor:active_item() and IAmAWeapon[db.actor:active_item():clsid()] then
    key = self:get_key_from_distance(self.a.victim_wpn)
    if key ~= nil then
      return tostring(xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.victim_wpn[key].state))
    end
  else
    key = self:get_key_from_distance(self.a.victim)
    if key ~= nil then
      return tostring(xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.victim[key].state))
    end
  end
  return "nil"
end

function Cmeet_manager:actor_targets_npc(npc) counterAdd("xr_meet.Cmeet_manager:actor_targets_npc")
  local dangerang=1/npc:position():distance_to(db.actor:position())
  local ang=horz_angle(device().cam_dir,npc:position():sub(device().cam_pos))
  local tgt=ang>-dangerang and ang<dangerang
  if tgt then
    if self.tgt_time then
      return self.tgt_time<time_global()
    else
      self.tgt_time=time_global()+600
      return false
    end
  else
    self.tgt_time=nil
  end
  return false
end


function Cmeet_manager:get_key_from_distance(t) counterAdd("xr_meet.Cmeet_manager:get_key_from_distance")
  local key
  for k,v in pairs(t) do
    if v.dist >= self.dist then
      key = k
    else
      return key
    end
  end
  return key
end
function Cmeet_manager:get_key_from_zone(t) counterAdd("xr_meet.Cmeet_manager:get_key_from_zone")
  for k,v in pairs(t) do
    if utils.npc_in_zone(db.actor, db.zone_by_name[v.zone]) then
      return k
    end
  end
  return nil
end
function Cmeet_manager:process_use() counterAdd("xr_meet.Cmeet_manager:process_use")
  local is_talking = self.npc:is_talking()
  -- запрещаем юзать спящих
  if xr_sleeper.is_npc_asleep(self.npc) then
    self.npc:disable_talk()
    self.disable_talk_weapon = false
    if is_talking then
      self.npc:stop_talk()
    end
    return
  end

  local t
  if db.actor:active_item() and IAmAWeapon[db.actor:active_item():clsid()] then
    t = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.use_wpn)
    if t == "false" then
      self.disable_talk_weapon = true
    end
  else
    t = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.use)
    self.disable_talk_weapon = false
  end
  -- проверка по дистанции
  if (is_talking and self.npc:position():distance_to_sqr(db.actor:position()) > 9) and
    t ~= "self"
  then
    self.npc:stop_talk()
  end

  if t == "true" then
    self.npc:enable_talk()
  elseif t == "false" then
    self.npc:disable_talk()
    if is_talking then
      self.npc:stop_talk()
    end
  elseif t == "self" then
    if not is_talking then
      db.actor:run_talk_dialog(self.npc)
    end
  end
end

----------------------------------------------------------------------------------------------------------------------
-- binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(object, char_ini, scheme, section, st) counterAdd("xr_meet.add_to_binder")
  local operators   = {}
  local properties  = {}

  local manager = object:motivation_action_manager()

  properties["contact"]   = xr_evaluators_id.stohe_meet_base + 1
  properties["wounded"]   = xr_evaluators_id.sidor_wounded_base
  properties["abuse"]     = xr_evaluators_id.abuse_base

  operators["contact"]    = xr_actions_id.stohe_meet_base + 1
  operators["state_mgr_to_idle_alife"]  = xr_actions_id.state_mgr + 2

  -- Evaluators
  manager:add_evaluator (properties["contact"],     evaluator_contact("meet_contact", st))

  -- Actions
  local action = action_meet_wait (object:name(),"action_process_meet", st, char_ini)
  action:add_precondition   (world_property(stalker_ids.property_alive, true))
  action:add_precondition   (world_property(stalker_ids.property_enemy, false))
  action:add_precondition   (world_property(stalker_ids.property_danger,false))
  action:add_precondition   (world_property(stalker_ids.property_anomaly,false))
  action:add_precondition   (world_property(watcher_act.evid_near_stuff, false))
  action:add_precondition   (world_property(properties["contact"],    true))
  action:add_precondition   (world_property(properties["wounded"],    false))
  action:add_precondition   (world_property(properties["abuse"],    false))
  action:add_effect (world_property(properties["contact"],      false))
  manager:add_action (operators["contact"], action)

  action = manager:action (xr_actions_id.alife)
  action:add_precondition   (world_property(properties["contact"],    false))

  action = manager:action (operators["state_mgr_to_idle_alife"])
  action:add_precondition   (world_property(properties["contact"],    false))

  st.meet_manager = Cmeet_manager(object, st)
end



------------
-- Вызывается только в начале на чтении логики, создает экшены, эвалуаторы и производит
-- первичную настройку.
function set_meet(npc, ini, scheme, section) counterAdd("xr_meet.set_meet")
  local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
end
-- Вызывается на переключении на новую секцию. Производит вычитывание настроек из текущей секции.
function reset_meet(npc, scheme, st, section) counterAdd("xr_meet.reset_meet")
  local meet_section
  if scheme == nil or scheme == "nil" then
    meet_section = utils.cfg_get_string(st.ini, st.section_logic, "meet", npc, false, "")
  else
    meet_section = utils.cfg_get_string(st.ini, section, "meet", npc, false, "")
  end
  if meet_section == "default_meet" then
    if scheme == "kamp" then
      init_meet(npc, st.ini, nil, st.meet, scheme)
    else
      init_meet(npc, st.ini, nil, st.meet, nil)
    end
  else
    init_meet(npc, st.ini, meet_section, st.meet, scheme)
  end
end
-- Функция чтения настроек. В нее передается секция, откуда их нужно читать.

local tbl_npc = {}

function tbl_refresh()
tbl_npc = {}
end

function init_meet(npc, ini, section, st, scheme) counterAdd("xr_meet.init_meet")
local state
for _, v in ipairs(tbl_npc) do
	if string.find(tbl_npc,npc:id()) then 
	amk.send_tip("с ним уже здоровались", "ДА", 0, 15, "common_channel")
	state = 0
	else	
	amk.send_tip("с этим еще не здоровались", "НЕТ", 0, 15, "common_channel")
	state = 1
	end 
	end
	if state == 1 then 
	table.insert(tbl_npc, npc:id())
	end


  if tostring(section) == st.meet_section and
     tostring(section) ~= "nil"
  then
    return
  end

  st.meet_section = tostring(section)

  -- Устанавливаем дефолты
  local def = {}
  local npc_community = npc:character_community()
  if tostring(scheme) == "nil" or tostring(scheme) == "default" then
    def.meet_state    = "2|wait@hail"
    def.meet_state_wpn  = "5|backoff@threat_weap"
    def.init_meet   = "talk_hello"
    def.victim      = "5|actor"
    def.victim_wpn    = "5|actor"
    def.use       = "true"
    def.use_wpn     = "false"
    def.syndata     = "backoff@threat_weap"
    def.precond     = "visibility"
    def.abuse     = "true"
  elseif tostring(scheme) == "kamp" then
    def.meet_state    = "2|wait@hail"
    def.meet_state_wpn  = ""
    def.init_meet   = ""
    def.victim      = "2|actor"
    def.victim_wpn    = ""
    def.use       = "{=_kamp_talk}true,false"
    def.use_wpn     = "false"
    def.syndata     = ""
    def.precond     = "usability"
    def.abuse     = "true"
  --[[elseif npc_community == "monolith" or
    --npc_community == "killer" or
    npc_community == "zombied" then
    def.meet_state    = ""
    def.meet_state_wpn  = ""
    def.init_meet   = ""
    def.victim      = ""
    def.victim_wpn    = ""
    def.use       = "false"
    def.use_wpn     = "false"
    def.syndata     = ""
    def.precond     = "visibility"
    def.abuse     = "false"]]


elseif npc_community == "zombied" then
   def.meet_state    = "2|wait@hail"
    def.meet_state_wpn  = "5|backoff@threat_weap"
    def.init_meet   = "talk_hello"
    def.victim      = "5|actor"
    def.victim_wpn    = "5|actor"
    def.use       = "true"
    def.use_wpn     = "false"
    def.syndata     = "backoff@threat_weap"
    def.precond     = "visibility"
    def.abuse     = "false"





elseif npc_community == "fotoman" then
    def.meet_state    = ""
    def.meet_state_wpn  = ""
    def.init_meet   = ""
    def.victim      = ""
    def.victim_wpn    = ""
    def.use       = "false"
    def.use_wpn     = "false"
    def.syndata     = ""
    def.precond     = "visibility"
    def.abuse     = "false"
	elseif npc_community == "military" or
           npc_community == "bandit" then
    def.meet_state    = ""
    def.meet_state_wpn  = ""
    def.init_meet   = ""
    def.victim      = ""
    def.victim_wpn    = ""
    def.use       = "true"
    def.use_wpn     = "false"
    def.syndata     = ""
    def.precond     = "visibility"
    def.abuse     = "true"
  else
    def.meet_state    = "2|wait"
    def.meet_state_wpn  = ""
    def.init_meet   = ""
    def.victim      = "2|actor"
    def.victim_wpn    = ""
    def.use       = "true"
    def.use_wpn     = "false"
    def.syndata     = ""
    def.precond     = "visibility"
    def.abuse     = "true"
  end


if tostring(section) == "nil" or tostring(section) == "default" then
    -- Загружаем дефолты!
    st.meet_state   = parse_data(npc, def.meet_state)
    st.meet_state_wpn = parse_data(npc, def.meet_state_wpn)
    st.init_meet    = def.init_meet
    st.victim     = parse_data(npc, def.victim)
    st.victim_wpn   = parse_data(npc, def.victim_wpn)
    st.use        = xr_logic.parse_condlist( def.use, npc, section, "use" )
    st.use_wpn      = xr_logic.parse_condlist( def.use_wpn, npc, section, "use_wpn" )
    st.meet_dialog    = xr_logic.parse_condlist( "", npc, section, "meet_dialog" )
    st.zone       = parse_zone_data(npc, "")
    st.syndata      = parse_syn_data(npc, def.syndata)
    st.precond      = def.precond
    st.abuse      = def.abuse
  elseif tostring(section) == "no_meet" then
    st.meet_state   = parse_data(npc, "")
    st.meet_state_wpn = parse_data(npc, "")
    st.init_meet    = ""
    st.victim     = parse_data(npc, "")
    st.victim_wpn   = parse_data(npc, "")
    st.use        = xr_logic.parse_condlist( "false", npc, section, "use" )
    st.use_wpn      = xr_logic.parse_condlist( "false", npc, section, "use_wpn" )
    st.meet_dialog    = xr_logic.parse_condlist( "", npc, section, "meet_dialog" )
    st.zone       = parse_zone_data(npc, "")
    st.syndata      = parse_syn_data(npc, "")
    st.precond      = "usability"
    st.abuse      = "false"
  else
    st.meet_state   = parse_data(npc, utils.cfg_get_string(ini, section, "meet_state", npc, false, "", def.meet_state))
    st.meet_state_wpn = parse_data(npc, utils.cfg_get_string(ini, section, "meet_state_wpn", npc, false, "", def.meet_state_wpn))
    st.init_meet    = utils.cfg_get_string(ini, section, "init_meet", npc, false, "", def.init_meet)
    st.victim     = parse_data(npc, utils.cfg_get_string(ini, section, "victim", npc, false, "", def.victim))
    st.victim_wpn   = parse_data(npc, utils.cfg_get_string(ini, section, "victim_wpn", npc, false, "", def.victim_wpn))
    st.use        = xr_logic.parse_condlist( utils.cfg_get_string(ini, section, "use", npc, false, "", def.use), npc, section, "use" )
    st.use_wpn      = xr_logic.parse_condlist( utils.cfg_get_string(ini, section, "use_wpn", npc, false, "", def.use_wpn), npc, section, "use_wpn" )
    st.meet_dialog    = xr_logic.parse_condlist( utils.cfg_get_string(ini, section, "meet_dialog", npc, false, "", ""), npc, section, "meet_dialog" )
    st.zone       = parse_zone_data(npc, utils.cfg_get_string(ini, section, "zone", npc, false, ""))
    st.syndata      = parse_syn_data(npc, utils.cfg_get_string(ini, section, "synpairs", npc, false, "", def.syndata))
    st.precond      = utils.cfg_get_string(ini, section, "precond", npc, false, "", def.precond)
    st.abuse      = utils.cfg_get_string(ini, section, "abuse", npc, false, "", def.abuse)
  end

  -- Проверяем включать ли обижание на заюзывание
  if st.abuse == "true" then
    xr_abuse.enable_abuse(npc)
  else
    xr_abuse.disable_abuse(npc)
  end

  -- флажок, что функция хотя бы раз вызывалась
  st.meet_set = true
end

--!!!TODO: кешировать !!!
function parse_data(npc,s) counterAdd("xr_meet.parse_data")
  local t = {}

  if s then
    local string_find = string.find
    local string_sub = string.sub
    local table_insert = table.insert
    for name in string.gfind( s, "(%|*%d+%|[^%|]+)%p*" ) do
      local dat = { dist = nil,
              state = nil,
              sound = nil}

      local t_pos = string_find( name, "|", 1, true )
      local s_pos = string_find( name, "@", 1, true )

      local dist = string_sub( name, 1, t_pos - 1 )
      local state
      local sound

      if s_pos then
        state = string_sub( name, t_pos + 1,
                      s_pos - 1 )
        sound = string_sub( name, s_pos + 1)
      else
        state = string_sub( name, t_pos + 1)
      end
      dat.dist = tonumber(dist)
      if state then
        dat.state = xr_logic.parse_condlist( state, npc, dist, state )
      end
      if sound then
        dat.sound = xr_logic.parse_condlist( sound, npc, dist, sound )
      end
      table_insert(t, dat)
    end
  end
    return t
end

--!!!TODO: кешировать !!!
function parse_zone_data(npc,s) counterAdd("xr_meet.parse_zone_data")
  local t = {}

  if s then
    local string_find = string.find
    local string_sub = string.sub
    local table_insert = table.insert
    for name in string.gfind( s, "(%|*[^%|]+%|[^%|]+)%p*" ) do
      local dat = { zone = nil,
              state = nil,
              sound = nil}

      local t_pos = string_find( name, "|", 1, true )
      local s_pos = string_find( name, "@", 1, true )

      local zone = string_sub( name, 1, t_pos - 1 )
      local state
      local sound

      if s_pos then
        state = string_sub( name, t_pos + 1,
                      s_pos - 1 )
        sound = string_sub( name, s_pos + 1)
      else
        state = string_sub( name, t_pos + 1)
      end
      dat.zone = zone
      if state then
        dat.state = xr_logic.parse_condlist( state, npc, zone, state )
      end
      if sound then
        dat.sound = xr_logic.parse_condlist( sound, npc, zone, sound )
      end
      table_insert(t, dat)
    end
  end

    return t
end

--!!!TODO: кешировать !!!
function parse_syn_data(npc,s) counterAdd("xr_meet.parse_syn_data")
  local t = {}
  if s then
    local string_find = string.find
    local string_sub = string.sub
    local table_insert = table.insert
    for name in string.gfind( s, "(%|*[^%|]+%|*)%p*" ) do
      local dat = { zone = nil,
              state = nil,
              sound = nil}
      local t_pos = string_find( name, "@", 1, true )
      local s_pos = string_find( name, "|", 1, true )

      local state = string_sub( name, 1, t_pos - 1 )
      local sound
      if s_pos then
        sound = string_sub( name, t_pos + 1, s_pos -1)
      else
        sound = string_sub( name, t_pos + 1)
      end

      dat.state = state
      dat.sound = sound
      table_insert(t, dat)
    end
  end

    return t
end

-- ДИАЛОГИ ПОКА НЕ ТРОГАЕМ!!!
--' Считывание доступных диалогов игрока.
function set_actor_dialogs(npc, ini, name, dialog_section) counterAdd("xr_meet.set_actor_dialogs")
  if dialog_section == nil then return end
  local actor_dialogs_string = utils.cfg_get_string(ini, dialog_section, "id", npc, false, "")
  if actor_dialogs_string ~= nil then
    --' Создаем в массиве запись где будут храниться считанные диалоги.
    db.storage[npc:id()].actor_dialogs = parse_names(actor_dialogs_string)
  end

  local actor_disable = utils.cfg_get_string(ini, dialog_section, "disable", npc, false, "")
  if actor_disable ~= nil then
    --' Создаем в массиве запись где будут храниться считанные диалоги.
    db.storage[npc:id()].actor_disable = parse_names(actor_disable)
  end
end
--' ВНИМАНИЕ: Эта функция вызывается и для сталкеров, и для монстров!
function dialog_manager_reset(npc, stype) counterAdd("xr_meet.dialog_manager_reset")
  if stype == modules.stype_mobile then
    --' Смена стартового диалога
    local overrides = xr_logic.generic_scheme_overrides(npc)
    if overrides ~= nil then
      if overrides.meet_dialog then
        npc:set_start_dialog(overrides.meet_dialog)
      else
        npc:restore_default_start_dialog()
      end
    else
      npc:restore_default_start_dialog()
    end
  end
end
function disable_scheme(npc, scheme) counterAdd("xr_meet.disable_scheme")
  db.storage[npc:id()].actor_dialogs = nil
  db.storage[npc:id()].actor_disable = nil
end

--- Находится ли чувак в данный момент в состоянии мита
function is_meet(npc) counterAdd("xr_meet.is_meet")
  local manager = npc:motivation_action_manager()
  if manager and manager:initialized() then
    local id = manager:current_action_id()
    if id == xr_actions_id.stohe_meet_base + 1 then
      return true
    end
  end
  return false
end
-- Функция проверяет не мешает ли персонажу говорить с нами оружие
function cannot_talk_by_weapon(npc) counterAdd("xr_meet.cannot_talk_by_weapon")
  local st = db.storage[npc:id()].meet
  if st then
    if not db.actor:active_item() or not IAmAWeapon[db.actor:active_item():clsid()] then
      return false
    end
    if st.use then
      local t = xr_logic.pick_section_from_condlist(db.actor, npc, st.use)
      if t == "false" then
        return false
      end
    end
    if st.use_wpn then
      local t = xr_logic.pick_section_from_condlist(db.actor, npc, st.use_wpn)
      if t == "false" then
        return true
      end
    end
  end
  return false
end

-- Возвращает угол между проекциями векторов vec1 и vec2 на горизонтальную плоскость
-- положительный угол - доворот vec1 до vec2 по часовой.
function horz_angle(vec1,vec2) counterAdd("xr_meet.horz_angle")
  local x=vec2.x*vec1.x+vec2.z*vec1.z
  local y=-vec2.z*vec1.x+vec2.x*vec1.z -- повернули систему координат
  return math.atan2(y,x) -- угол доворота от -pi до pi
end
