-- Idler: файл из мода 'Народная солянка 2.0'. Адаптирован для мода 'Метки с хабаром 2.1.2' 30.09.2008 0:08:52
-- добавлена fenechka by TAG

local table_sort = table.sort
local table_remove = table.remove
local table_insert = table.insert
local math_floor = math.floor
local math_random = math.random
local math_sqrt = math.sqrt
local string_sub = string.sub
local string_find = string.find
local string_byte = string.byte
local string_char = string.char
local string_match = string.match
local string_len = string.len
local string_gsub = string.gsub
local string_rep = string.rep
local string_gfind = string.gfind
local string_format = string.format

----------------

local timers		--хранит реал-тайм таймеры
local timers_id_name = {}
local timers_name_id = {}
-- local g_timers={}	--хранит таймеры в игровом времени
local markers={}	--хранит маркеры на карте
local x_objs={}		--хранит ИДшники объектов
local timer_trigger=nil
local force_offline = _G.force_offline
if not force_offline then 
 force_offline = {}
 _G.force_offline = force_offline
end
convert_npc = force_offline
g_kick=false
oAmkLauncher = amkII_launcher.CAmkLauncher()
local StartTime
ver = "0"
oau_watchdog = 0
oau_reason = ""
--переменные для типсов
pda_news = xr_sound.get_safe_sound_object([[device\pda\pda_news]])
pda_tips = xr_sound.get_safe_sound_object([[device\pda\pda_tip]])
pda_task = xr_sound.get_safe_sound_object([[device\pda\pda_objective]])

tips_icons = {
	default		={ 0,	658 },
	trader		={ 332, 893 },
	dolg		={ 0,	658 },
	freedom		={ 0,	658 },
	ecolog		={ 498, 0   },
	arena		={ 332, 141 },
	stalker		={ 0,	658 },
	krot		={ 332,	47  },
	barman		={ 332,	235 },
	wolf		={ 332,	940 },
	o_soznanie	={ 498,	893 },
	monolith	={ 0,	658 },
	saharov		={ 332,	470 },
	prizrak		={ 0,	658 },
	killer		={ 0,	658 },
	death		={ 0,	752 },
	common_channel = {498, 47},
	gen_info	={ 0,	658 },
	trade		={ 0,	0   },
	uniq		={ 498,	47  }	--{ 498, 188}
}


--показываем типс
function send_tip(news_text, header, timeout, showtime, sender, sound)
	if news_text==nil then return end
	if header==nil then return end-- header=game.translate_string("st_tip") end
	if header=="nil" then return end-- header=game.translate_string("st_tip") end
--	if header=="" then return end-- header=game.translate_string("st_tip") end
	if timeout == nil then timeout = 0 end
	if showtime == nil then showtime = 5 end
  
	local player
	if sound=="news" then player=pda_news
	elseif sound=="task" then player=pda_task
	else player=pda_tips
	end   
  
	--' Играем дефолтный звук
	player:play(db.actor, timeout, sound_object.s2d)
  
	if sender == nil then sender = "default" end
	local x = tips_icons[sender][1]
	local y = tips_icons[sender][2]
  
	local news_text = "%c[255,160,160,160]"..header.."\\n".."%c[default]"..news_text
	db.actor:give_game_news(news_text, "ui\\ui_iconsTotal", Frect():set(x,y,83,47), timeout*1000, showtime*1000)
	return true
end

function add_spot_on_map(obj_id,type,text)
	--возможные типы type смотри в ui\map_spots.xml 
	if obj_id then
		if text==nil then text=" " end
		-- Ставим метку на серверный объект чтобы её не пришлось обновлять
		level.map_add_object_spot_ser(obj_id, type, text)
		-- save_variable("x_marker_type_"..obj_id, type)
		-- save_variable("x_marker_text_"..obj_id, text)
	end
end

function remove_spot_from_map(obj_id,type)
	if obj_id and level.map_has_object_spot(obj_id, type)~= 0 then
		level.map_remove_object_spot(obj_id, type)
		-- del_variable("x_marker_type_"..obj_id)
		-- del_variable("x_marker_text_"..obj_id)
	end
end

--старт таймера в реальном времени
--function start_timer(name,delay,action)
function start_timer(name, delay, parameters)

	if not delay then return false end
	if not parameters then parameters = "" end

	if not timers then
		timers = load_table("timers")
	end

	table_insert(timers, {timers_name_id[name], math_floor(game_milliseconds() + delay * 1000 * getIniValueFloatSimple("alife","time_factor", 5)), parameters})

	-- сортируем для оптимизации дальнейшего поиска по таймерам
	-- таймеры с меньшим временем будут в конце таблицы
	table_sort(timers, timersSort)
	save_table("timers", timers)
	return true
end

-- функция сравнения для сортировки таймеров
-- в конце таблицы таймеры с самым маленьким временем
function timersSort(t1, t2)
	return t1[2] > t2[2]
end

--старт таймера в игровом времени
--function g_start_timer(name,delay_d,delay_h,delay_m,action)
function g_start_timer(name, delay_d, delay_h, delay_m, parameters)
	if delay_d == nil or delay_h == nil or delay_m == nil then return false end
	if not parameters then parameters = "" end
	if not timers then timers = load_table("timers") end

	table_insert(timers, {timers_name_id[name], math_floor(game_milliseconds() + (delay_d*60*24+delay_h*60+delay_m) * 60 * 1000), parameters})

	-- сортируем для оптимизации дальнейшего поиска по таймерам
	-- таймеры с меньшим временем будут в конце таблицы
	table_sort(timers, timersSort)
	
	save_table("timers", timers)
	return true
end

function has_timer(name)
	if not timers then timers = load_table("timers") end
	for i = 1, #timers do
		if timers[i][1] == timers_name_id[name] then return true, timers[i][2], timers[i][3] end
	end
	return false, ""
end

function remove_timer(name)
	if not timers then timers = load_table("timers") end
	for i = #timers, 1, -1 do
		if timers[i][1] == timers_name_id[name] then table_remove(timers, i) end
	end

	-- сортируем для оптимизации дальнейшего поиска по таймерам
	-- таймеры с меньшим временем будут в конце таблицы
	table_sort(timers, timersSort)
	save_table("timers", timers)
end

has_g_timer = has_timer
--[[
function has_g_timer(name)
	return has_timer(name)
end
]]

-- Временное хранилище для переменных удалённых из pstor
local emerg_store
-- Удаляем переменные из pstor. Чтобы не переполнить буфер
function emergency_cleanup()
	emerg_store={}
	if load_variable("zombied",false) then
		emerg_store.zombied=load_table("zombied")
		del_variable("zombied")
	end
	emerg_store.timers = load_table("timers")
	del_variable("timers")
	save_variable("emerg",true)
end

-- Восстанавливаем удалённые переменные
function emergency_restore()
	if emerg_store.zombied then save_table("zombied", emerg_store.zombied) end
	save_table("timers", emerg_store.timers)
	del_variable("emerg")
end

function convert_timers()
	if not timers then timers = load_table("timers") end
	if load_variable("tmcv2",true) then
		local tmp
		local tmp_s
		local name,delay,params
		local g_milliseconds = game_milliseconds()
		--local time_factor = system_ini():r_float("alife","time_factor")
		local time_factor = getIniValueFloatSimple("alife","time_factor",5)
		local timers_to_unpack = 
		{
			["af_transform"]		= true,
			["af_transform_universal"]	= true,
			["sleep_repbox"]		= true,
			["repbox_cond"]			= true,
			["set_condition"]		= true,
			["healing_enemies"]		= true,
			["timer_drop_obj_varka"]	= true,
			["timer_drop_obj_transform"]	= true,
			["timer_drop_obj_teleport"]	= true,
			["timer_drop_obj_hand_teleporter"] = true 
		}
		for a=1,100,1 do
			-- реальные таймеры
			-- очень старые таймеры
			tmp_s = string_format("x_timer_%s",a)
			tmp=load_variable(tmp_s, nil)
			if tmp ~= nil then
				name = tmp
				delay = load_variable(string_format("%s_delay",tmp_s),0)
				params = load_variable(string_format("%s_params",tmp_s),"")
				-- 400499000 -- поправка на разницу с game.time()
				if timers_to_unpack[name] == true then
					params = unpack_array_from_string(params)
				end
				table_insert(timers, {name, math_floor(delay - 400499000), params})
				del_variable(tmp_s)
				del_variable(string_format("%s_delay",tmp_s))
				del_variable(string_format("%s_params",tmp_s))
			end
			-- старые таймеры
			name = load_variable("xt"..a, nil)
			if name ~= nil then
				delay	= load_variable("xd"..a, nil)
				params	= load_variable("xp"..a, nil)
				-- 400499000 -- поправка на разницу с game.time()
				if timers_to_unpack[name] == true then
					params = unpack_array_from_string(params)
				end
				table_insert(timers, {name, math_floor(delay - 400499000), params})
				del_variable("xt"..a)
				del_variable("xd"..a)
				del_variable("xp"..a)
			end
			-- игровые таймеры
			-- очень старые таймеры
			tmp=load_variable("x_gtimer_"..a,nil)
			if tmp~=nil then
				name,delay,params=tmp,load_variable("x_gtimer_"..a.."_delay",0),load_variable("x_gtimer_"..a.."_params","")
				if timers_to_unpack[name] == true then
					params = unpack_array_from_string(params)
				end
				table_insert(timers, {name, math_floor(delay * 60 * 1000), params})
				del_variable("x_gtimer_"..a)
				del_variable("x_gtimer_"..a.."_delay")
				del_variable("x_gtimer_"..a.."_params")
			end
			-- старые таймеры
			name = load_variable("gt"..a, nil)
			if name ~= nil then
				delay = load_variable("gd"..a, nil)
				params = load_variable("gp"..a, nil)
				if timers_to_unpack[name] == true then
					params = unpack_array_from_string(params)
				end
				table_insert(timers, {name, math_floor(delay * 60 * 1000), params})
				del_variable("gt"..a)
				del_variable("gd"..a)
				del_variable("gp"..a)
			end
		end
		save_variable("tmcv2",false)
		-- сортируем для оптимизации дальнейшего поиска по таймерам
		-- таймеры с меньшим временем будут в конце таблицы
		table_sort(timers, timersSort)
		save_table("timers", timers)
	end
	
	if load_variable("tmcv3",true) then
		-- переводим таймеры с имен на ID
		local timers_new = {}
		for i = 1, #timers do
			if type(timers[i][1]) == "string" then
				table_insert(timers_new, {timers_name_id[timers[i][1]], timers[i][2], timers[i][3]})
			else
				table_insert(timers_new, {timers[i][1], timers[i][2], timers[i][3]})
			end
		end
		timers = timers_new
		
		-- сортируем для оптимизации дальнейшего поиска по таймерам
		-- таймеры с меньшим временем будут в конце таблицы
		table_sort(timers, timersSort)
		save_table("timers", timers)
		save_variable("tmcv3",false)
	end
end

--проверка таймеров
function check_timers()
	if not timers then timers = load_table("timers") end
	local id, name -- ID, имя действия
	local delay -- задержка в игровых миллисекундах
	local parameters -- параметры действия
	local timersToStart = {} -- список таймеров на запуск, которые запустятся после очистки таблицы, так как таблица может одновременно чистится и заполнятся в процессе запуска действий
	local milliseconds = game_milliseconds()
	
	for i = #timers, 1, -1 do -- идём с хвоста по таймерам с наименьшим временем срабатывания
		id			= timers[i][1]
		name		= timers_id_name[id]
		delay		= timers[i][2]
		parameters	= timers[i][3]
		--if type(parameters) == "table" then
		--	parameters = pack_array_to_string(parameters)
		--end
		if delay <= milliseconds then
			table_insert(timersToStart, {name, parameters})
			table_remove(timers) -- сначала чистим таблицу, а то ещё в __do_timer_action() она может быть дополнена
		else -- таймеров с временем меньшим за текущее уже нет, так как таблица была отсортирована
			break
		end
	end

	if #timersToStart > 0 then -- какие-то таймеры сработали и были удалены из таблицы
		-- перезаписываем таблицу
		save_table("timers", timers)
	
		-- запуск действий на выполнение
		for i = 1, #timersToStart do
			name		= timersToStart[i][1]
			parameters	= timersToStart[i][2]
			oau_reason = name--.." "..parameters -- для протокола в случае слежки
			__do_timer_action(name, parameters)		
		end
	end
end

-- таблица функций для ускорения их вызовов
-- используется ниже
local func_by_string = {}
	func_by_string["tag_trup_to_zombie"] = function (params_string)
		tag_spb.trup_to_zombie(params_string)
	end
	func_by_string["sidor_trader_repair"] = function (params_string)
		ui_repair_menu.set_order_ready( params_string, 1 )
	end
	func_by_string["dolgovyazyj_trader_repair"] = function (params_string)
		ui_repair_menu.set_order_ready( params_string, 1 )
	end
	func_by_string["shurup_trader_repair"] = function (params_string)
		ui_repair_menu.set_order_ready( params_string, 1 )
	end
	func_by_string["vasiliy_trader_repair"] = function (params_string)
		ui_repair_menu.set_order_ready( params_string, 1 )
	end
	func_by_string["petr_trader_repair"] = function (params_string)
		ui_repair_menu.set_order_ready( params_string, 1 )
	end
	func_by_string["jupiter_rem_trader_repair"] = function (params_string)
		ui_repair_menu.set_order_ready( params_string, 1 )
	end
	func_by_string["unload_o_weapon"] = function (params_string)
		ui_repair_menu.unload_weapon( params_string )
	end
	func_by_string["sms_new"] = function (params_string)
		braad_test.sms_new()
	end
	func_by_string["boroda_sosolov_sms"] = function (params_string)
	sol_utils.send_tip( "%c[255,160,160,160]".."БОРОДА:".."\\n".."%c[255,255,128,128]Привет, это Борода. Разведка доложила, что видели этого охотника в районе пионерлагеря.", nil, nil, 30000)
	db.actor:give_info_portion("boroda_say_tri_start")
	end
	func_by_string["sms_new1"] = function (params_string)
		braad_test.sms_new1()
	end
	func_by_string["luis_killself"] = function (params_string)
		braad_test.luis_killself()
	end
	func_by_string["delete_black_doctor"] = function (params_string)
		braad_test.delete_black_doctor()
	end
	func_by_string["show_news"] = function (params_string)
		amk_mod.show_news()
	end
	func_by_string["gg_need_sleep"] = function (params_string)
		amk_mod.test_for_need_sleep()
	end
	func_by_string["block_sleep_menu"] = function (params_string)
		save_variable("block_sleep_menu",0)
	end
	func_by_string["af_transform"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = amk.unpack_array_from_string(params_string)
		end
		amk_mod.af_transform_end(tbl)
	end
	func_by_string["af_transform_universal"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = amk.unpack_array_from_string(params_string)
		end
		amk_mod.af_transform_universal_end(tbl)
	end
	func_by_string["amk_freeplay"] = function (params_string)
		if amk.load_variable("freeplay",0)==1 and level.name()=="l12_stancia_2" then
			xr_effects.game_credits()
		end
	end
	func_by_string["blowout"] = function (params_string)
		amk_mod.Blowout_pp(params_string)
	end
	func_by_string["test"] = function (params_string)
		amk_mod.Run_Blowout_pp()
	end
	func_by_string["blowout_ss"] = function (params_string)
		amk_mod.blowout_scary_sounds()
	end
	func_by_string["blow_shift"] = function (params_string)
		amk_mod.Run_Blowout_pp()
	end
	func_by_string["sleep_repbox"] = function (params_string)
		amk_mod.repair_weapon(params_string)
	end
	func_by_string["repbox_cond"] = function (params_string)
		amk_mod.after_repair_weapon(params_string)
	end
	func_by_string["collect_anomalies_info"] = function (params_string)
		amk_anoms.collect_info()
	end
	func_by_string["news_check"] = function (params_string)
		if (news_main and news_main.check_news) then news_main.check_news() end
 	end
	func_by_string["set_condition"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local data
		if type(params_string) == "table" then
			data = params_string
		else
			data = unpack_array_from_string(params_string)
		end
		local a = level.object_by_id(data[1])
		if a then
			a:set_condition(data[2]/100)
			if IAmAOutfit[a:clsid()] then
				bind_stalker.outfit_restored = false
			end
		end
 	end
	func_by_string["set_condition_wpn_spawn"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local data
		if type(params_string) == "table" then
			data = params_string
		else
			data = unpack_array_from_string(params_string)
		end
		bind_wpn.set_condition(data[1])
 	end
	func_by_string["set_patroni"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local data
		if type(params_string) == "table" then
			data = params_string
		else
			data = unpack_array_from_string(params_string)
		end
		local a = level.object_by_id(data[1])
		if a then 
			a:set_ammo_elapsed(data[2])
		end
 	end
	func_by_string["healing_enemies"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local arr
		if type(params_string) == "table" then
			arr = params_string
		else
			arr = unpack_array_from_string(params_string)
		end
		local id = arr[1]
		local name = arr[2]
		local comm = arr[3]
		local revers = arr[4]
		local npc = level.object_by_id(id)
		-- если нпс на текущей локации
		if npc then
			return ex_wound_help.auto_change(npc,name,comm,revers)
		end
		-- ГГ успел удрать на другую локу
		ex_wound_help.recovery_params(id,name,comm)
	end
	func_by_string["timer_drop_obj_varka"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end
		
		local sobj = alife():object(tbl.obj_id)
		if sobj == nil then	-- съели
			--amk.send_tip("съели","съели",0,15,"gen_info")
		elseif sobj.parent_id == 65535 then	-- выбросили
			--amk.send_tip("выбросили","выбросили",0,15,"gen_info")
			-- запускаем проверку на рецепт и, если успешно, варку
			local obj	= level.object_by_id(tbl.obj_id)
			local anom	= level.object_by_id(tbl.anom_id)
			if obj and anom then -- если чего само выпадет или будет вброшено в игру скриптом при переходе ГГ между уровнями, то obj == nil и аномалии тоже не будет
				local obj_sect	= obj:section()
				local obj_pos	= obj:position()
				local anom_sect	= anom:section()
				local anom_pos	= anom:position()
				amk_mod.check_af_transform(obj, obj_sect, obj_pos, tbl.anom_id, anom_sect, anom_pos, tbl.anom_radius, tbl.lv, tbl.gv)
			end
		-- else amk.send_tip("переложили","переложили",0,15,"gen_info")
		end
 	end
	func_by_string["timer_drop_obj_transform"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end
		
		local sobj = alife():object(tbl.obj_id)
		if sobj == nil then	-- съели
			--amk.send_tip("obj_id = "..tbl.obj_id.." type: "..type(tbl.obj_id),"съели",0,15,"gen_info")
		elseif sobj.parent_id == 65535 then	-- выбросили
			--amk.send_tip("выбросили","выбросили",0,15,"gen_info")
			-- запускаем трансформацию предмета
			local obj = level.object_by_id(tbl.obj_id)
			if obj then amk_mod.item_transform(tbl)	end
		-- else amk.send_tip("переложили","переложили",0,15,"gen_info")
		end
 	end
	func_by_string["timer_drop_obj_teleport"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end

		local sobj = alife():object(tbl.obj_id)
		if sobj == nil then	-- съели
			--amk.send_tip("съели","съели",0,15,"gen_info")
			spawn_level_changer.teleport_start(tbl.obj_sect, tbl.obj_id, true)
		elseif sobj.parent_id == 65535 then -- выбросили
			--amk.send_tip("выбросили","выбросили",0,15,"gen_info")
			-- запускаем телепорт
			spawn_level_changer.teleport_start(tbl.obj_sect, tbl.obj_id, false)
		-- else amk.send_tip("переложили","переложили",0,15,"gen_info")
		end
 	end

	func_by_string["autosave"] = function (params_string)
        u3_utils.savegame(params_string)
    end
	func_by_string["babah_drop_timeBomb"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end
		
		local sobj = alife():object(tbl.id)
		if sobj == nil then	-- съели/использовали
			--amk.send_tip("съели","съели",0,15,"gen_info")
			babah.useTimeBomb(tbl)
		elseif sobj.parent_id == 65535 then	-- выбросили
			--amk.send_tip("выбросили","выбросили",0,15,"gen_info")
			babah.dropTimeBomb(tbl)
		else	-- переложили
			--amk.send_tip("переложили","переложили",0,15,"gen_info")
			babah.relocateTimeBomb(tbl)
		end
 	end
	func_by_string["babah.onItemDropCheck"] = function (id)
		
		local sobj = alife():object(id)
		if sobj == nil then	-- съели/использовали
			-- amk.send_tip("съели","съели",0,15,"gen_info")
			--babah.useTimeBomb(tbl)
		elseif sobj.parent_id == 65535 then	-- выбросили
			-- amk.send_tip("выбросили","выбросили",0,15,"gen_info")
			babah.onItemDropCheck(id)
		else	-- переложили
			-- amk.send_tip("переложили","переложили",0,15,"gen_info")
			--babah.relocateTimeBomb(tbl)
		end
 	end
	func_by_string["babah_timeBomb_activated"] = function (params_string)
		local id = tonumber(params_string)
		babah.explosiveExplode(id)
 	end
	func_by_string["babah_explode_moved_timeBomb"] = function (params_string)
		local id = tonumber(params_string)
		babah.explodeMovedTimeBomb(id)
 	end
	func_by_string["babah_move_timeBomb"] = function (tbl)
		babah.moveTimeBomb(tbl)
 	end
	func_by_string["babah_timeBomb_transfer"] = function (params_string)
		local id = tonumber(params_string)
		babah.transferTimeBomb(id)
 	end
	func_by_string["babah_explode_biside_explosives"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end
		babah.explodeBisideExplosives(tbl)
 	end
	func_by_string["babah_drop_mine"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end
		local sobj = alife():object(tbl.id)
		if sobj == nil then	-- съели/использовали
			--amk.send_tip("съели","съели",0,15,"gen_info")
		elseif sobj.parent_id == 65535 then	-- выбросили
			--amk.send_tip("выбросили","выбросили",0,15,"gen_info")
			babah.dropMine(tbl)
		-- else amk.send_tip("переложили","переложили",0,15,"gen_info")
		end
 	end

	func_by_string["babah_activateMine"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end
		local sobj = alife():object(tbl.id)
		babah.addMine(sobj)
 	end

	func_by_string["babah_drop_detonator"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end
		local sobj = alife():object(tbl.id)
		if sobj == nil then	-- съели/использовали
			--amk.send_tip("съели","съели",0,15,"gen_info")
			babah.useDetonator(tbl.sect)
		-- elseif sobj.parent_id == 65535 then amk.send_tip("выбросили","выбросили",0,15,"gen_info")
		-- else amk.send_tip("переложили","переложили",0,15,"gen_info")
		end
 	end

	func_by_string["babah_activateDetonator"] = function (params_string)
		babah.explodeBombsByDetonator(params_string)
 	end

	func_by_string["babah_kamikazze_free"] = function (id)
		local id = tonumber(id)
		babah.kamikazzeFree(id)
 	end

	func_by_string["amkUseTransmutator"] = function (params_string)
        local id = tonumber(params_string)
		local sobj = alife():object(id)
		if sobj == nil then	-- съели/использовали
			--amk.send_tip("съели","съели",0,15,"gen_info")
			amk.oAmkLauncher:AddFunc("UseTransmutator", "amkII_transmutator.amkEnableDevice(2)")
		-- elseif sobj.parent_id == 65535 then amk.send_tip("выбросили","выбросили",0,15,"gen_info")
		-- else amk.send_tip("переложили","переложили",0,15,"gen_info")
		end
 	end

	func_by_string["UseTeleport"] = function (params_string)
        local id = tonumber(params_string)
		local sobj = alife():object(id)
		if sobj == nil then
			amk.oAmkLauncher:AddFunc("UseTeleport", "teleport_menu.EnableDevice(1)")
		-- elseif sobj.parent_id == 65535 then	-- выбросили
		-- else	-- переложили
		end
 	end

	func_by_string["UseAdminBook"] = function (params_string)
        local id = tonumber(params_string)
		local sobj = alife():object(id)
		if sobj == nil then
			amk.oAmkLauncher:AddFunc("UseAdminBook", "sysadmin.EnableDevice(1)")
		end
 	end
	
	func_by_string["UseRemnabor"] = function (params_string)
        local id = tonumber(params_string)
		local sobj = alife():object(id)
		if sobj == nil then
			amk.oAmkLauncher:AddFunc("UseRemnabor", "sh_remnabor.EnableDevice(1)")
		end
 	end

	func_by_string["RepairEnd"] =  function (params)
		sh_remnabor.oDevice:r_done(params)
	end

	func_by_string["thirst_change"] = function (params)
		monnoroch_thirst.mon_thirst:thirst_change_slow(params)
 	end

--dc-- А оно здесь надо ?
--	func_by_string["border_exit"] = function (params)
--		xr_detector.hit_actor(params)
--	end

	func_by_string["new_game"] = function (params)
		--level.remove_complex_effector(params)
		--level.remove_pp_effector(params)
		db.actor:restore_weapon()
		level.enable_input()
		level.show_indicators()
 	end

	func_by_string["check_npc_inventory"] = function (params)
		local sobj = alife():object(tonumber(params))
		if sobj and sobj.parent_id ~= 65535 and sobj.parent_id ~= 0 then
			local sobj_parent = alife():object(sobj.parent_id)
			if sobj_parent and IAmAStalker[sobj_parent:clsid()] and sobj_parent.alive and sobj_parent:alive() then
				inv_npc.set_need_update(sobj_parent.id)
			end
		end
 	end



	func_by_string["release_by_time"] = function (obj_name)
		local obj = obj_name and alife():object(obj_name)
		if obj then
			local gm_obj = level.object_by_id(obj.id)
			if gm_obj then
				set_offline(obj)
			end
			alife():release(obj, true)
		end
	end	

--- ex_all ----------------------------------------------------------------
func_by_string['timer_hoard'] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local tabl
		if type(params_string) == "table" then
			tabl = params_string
		else
			tabl = unpack_array_from_string(params_string)
		end
	local obj_id = tonumber(tabl[1])
	local obj_name = tostring(tabl[2])
	local sobj = alife():object(obj_id)
	-- Если нет объекта или это уже другой объект - работаем дальше:
	if not sobj or (sobj:name() ~= obj_name) then
		ex_hoard.hoard_teleport()
	end
end
func_by_string['timer_hoard_restrictor']=function(params_string)
	ex_hoard.point_stack()
end
func_by_string["horror_shift"]=function(params_string)
	ex_horror.run_horror_effect(params_string)
end
func_by_string["horror"]=function(params_string)
	ex_horror.horror_effects(params_string)
end
func_by_string["horror_ss"]=function(params_string)
	ex_horror.horror_scary_sounds(params_string)
end
func_by_string["monstr_ss"]=function(params_string)
	ex_horror.monstr_scary_sounds(params_string)
end
func_by_string["phantom_init"]=function(params_string)
	ex_horror.init_phantoms(params_string)
end
func_by_string["timer_bolt_pda"]=function(params_string)
	spawn_zombi.bolt_pda_repair()
end
func_by_string["timer_pda_voyak"]=function(params_string)
	spawn_zombi.pda_voyak_repair()
end
--- ex_all -------------------------------------------------------- end ---

--- sol_all ---------------------------------------------------------------
func_by_string['pes_snotvornoe'] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local tabl
		if type(params_string) == "table" then
			tabl = params_string
		else
			tabl = unpack_array_from_string(params_string)
		end
	local obj_id = tonumber(tabl[1])
	local obj_name = tostring(tabl[2])
	local sobj = alife():object(obj_id)
	-- Если нет объекта или это уже другой объект - работаем дальше:
	if not sobj or (sobj:name() ~= obj_name) then
		sol_item_drop.pes_snotvornoe()
	end
end
func_by_string["resuply_time3"] = function (params_string)
	-- обновление торговли у Сидора.
end
func_by_string["kpk_hide_start"] = function (params_string)
	arhara_dialog.pda_slom_sms1()
end
func_by_string["kpk_hide_show"] = function (params_string)
	arhara_dialog.enabl_karta()
end
--- sol_all ------------------------------------------------------- end ---

--- Kluk&Muxa Aver ---
func_by_string["muha_bazar_sms"]=function(params_string)
	arhara_dialog.muha_bazar_sms()
end
func_by_string["muha_bazar_sms1"]=function(params_string)
	arhara_dialog.muha_bazar_sms1()
end
--- Kluk&Muxa Aver ---

--- Old Village ---
func_by_string["village_pantera_otvet_sms"]=function(params_string)
	arhara_dialog.village_pantera_otvet_sms()
end
func_by_string["strelok_kluk_vopros1"]=function(params_string)
	arhara_dialog.strelok_kluk_vopros1()
end
func_by_string["village_kap_pda"]=function(params_string)
	arhara_dialog.village_kap_pda()
end
--- Old Village ---

func_by_string["freeman_call_sms"]=function(params_string)
	new_dialog.freeman_call_sms()
end

	func_by_string["enable_attachable_item_by_id"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local data
		if type(params_string) == "table" then
			data = params_string
		else
			data = unpack_array_from_string(params_string)
		end
		local torch = level.object_by_id(data[1])
		if torch then
			torch:enable_attachable_item(true)
		end
 	end
	func_by_string["activate_slot"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local data
		if type(params_string) == "table" then
			data = params_string
		else
			data = unpack_array_from_string(params_string)
		end
		local npc = level.object_by_id(data[1])
		local slot = data[2]
		if npc then
			npc:activate_slot(slot)
		end
 	end
	func_by_string["enable_or_delete_attachable_item_for_npc_by_section"] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local data
		if type(params_string) == "table" then
			data = params_string
		else
			data = unpack_array_from_string(params_string)
		end
		local npc = level.object_by_id(data[1])
		local snpc = alife():object(data[1])
		if npc and snpc then
			local torch = npc:object(data[2])
			if torch then
				local storch = alife():object(torch:id())
				if not storch then return end
				
				local lname = level.name()
				local sname = amk.load_variable("level_on_save","")
				
				local delete = not npc:alive() and not snpc.torch_on
				-- при переходе с другой локации фонарики не аттачатся - удалим их
				delete = delete and lname == sname
				-- если есть фонарик-клон и он не включен и хозяин мёртв -- удалить
				if delete then
					npc:drop_item(torch)
					alife():release(storch, true)
				else
					torch:enable_attachable_item(true)
					if npc:alive() then
						torch:enable_attachable_item(false)
					end
				end
			end
		end
 	end
	
	func_by_string["trade_reset"] = function (params_string)
		if bind_stalker.trader then
			trade_manager.trade_reset(bind_stalker.trader)
			amk.spawn_item_in_inv("wpn_knife_trade", bind_stalker.trader)
			amk.spawn_item_in_inv("scientist_suit_white_trade", bind_stalker.trader)
			start_timer("open_trade", 0.01)
		end
 	end
	
	func_by_string["open_trade"] = function (params_string)
		if bind_stalker.trader then
			local obj = bind_stalker.trader:object("wpn_knife_trade")
			local sobj = obj and alife():object(obj:id())
			if sobj then
				alife():release(sobj, true)
			end
			local obj = bind_stalker.trader:object("scientist_suit_white_trade")
			local sobj = obj and alife():object(obj:id())
			if sobj then
				alife():release(sobj, true)
			end
		end
	end
	
	func_by_string["trade_update"] = function (params_string)
		if bind_stalker.trader then
			bind_stalker.trader:switch_to_talk()
			trade_manager.update(bind_stalker.trader)
			bind_stalker.trader:switch_to_trade()
		end
 	end
	
function __do_timer_action(select_string,params_string)
--[[	здесь описываем вызовы, оформялять в виде
	if select_string=="название условия" then <вызов сторонних функций>
		-- можно передавать npc как параметр
	end

	-- user area, переделал в оптимизированный вид
	-- объявляем:
func_by_string["doc_1"] = function (params_string) бла-бла-бла end
-- объявлять выше перед __do_timer_action --^

	-- вызываем:
if func_by_srtring[select_string] then func_by_srtring[select_string](params_string) end
-- сухо и комфортно ]]
	
	if func_by_string[select_string] then
		func_by_string[select_string](params_string)
	end
	
end
--------------------------------------------------------------------------------------------------------------------

--спавним объекты на карту
--для спавна неписей смотрим config\creatures\spawn_sections.ltx - там написаны имена секций для разных типов неписей
function spawn_item(spawn_item, pos, gv,lv)
	if gv == nil then gv = db.actor:game_vertex_id() end
	if lv == nil then lv = db.actor:level_vertex_id() end
	return alife():create(spawn_item, pos, lv, gv)
end

--для спавна патронов используем spawn_ammo_in_inv
--[[function spawn_item_in_inv(spawn_item,npc)
	if npc==nil then npc=db.actor end
	return alife():create(spawn_item, npc:position(), npc:level_vertex_id(),
			npc:game_vertex_id(), npc:id())
end]]
--Спавним предметы в инвентарь актора, НПС, монстров, ящиков (поддерживаются и клиентские, и серверные объекты)
--ДЛЯ СПАВНА ПАТРОНОВ ИСПОЛЬЗОВАТЬ ОТДЕЛЬНУЮ ФУНКЦИЮ!!!
function spawn_item_in_inv(section, npc, num)
	local npc = npc or db.actor
	local num = num or 1

	local pos, lvi, gvi, pid, sobj
	if type(npc.id) == "function" then
		pos, lvi, gvi, pid = npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id()
	else
		pos, lvi, gvi, pid = npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id
	end

	local is_actor = pid == db.actor:id()
	local game_obj = level.object_by_id(pid)
	for i = 1, num do
		sobj = alife():create(section, pos, lvi, gvi, pid)
		if not is_actor and game_obj and sobj then
			level.client_spawn_manager():add(sobj.id, -1, fix_spawn_item_in_inv, game_obj) --Фикс пропадания доспавненного предмета при сейв/лоаде
		end
	end
	if num == 1 and sobj then
		return alife():object(sobj.id)
	end
end


--используем для спавна патронов
--[[function spawn_ammo_in_inv(spawn_item,number,npc)
	if npc==nil then npc=db.actor end
	if number > 0 then return se_respawn.create_ammo(spawn_item, npc:position(),
		npc:level_vertex_id(), npc:game_vertex_id(), npc:id(), number)
	end
end]]
--Спавним патроны в инвентарь актора, НПС, монстров, ящиков (поддерживаются и клиентские, и серверные объекты)
function spawn_ammo_in_inv(section, num, npc)
	if num < 1 then return end

	local npc = npc or db.actor

	local pos, lvi, gvi, pid
	if type(npc.id) == "function" then
		pos, lvi, gvi, pid = npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id()
	else
		pos, lvi, gvi, pid = npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id
	end

	local is_actor = pid == db.actor:id()
	local game_obj = level.object_by_id(pid)
	local num_in_box = get_u32(section, "box_size")
	while num > num_in_box or num > 0 do
		local sitem = alife():create_ammo(section, pos, lvi, gvi, pid, num < num_in_box and num or num_in_box)
		if not is_actor and game_obj and sitem then
			level.client_spawn_manager():add(sitem.id, -1, fix_spawn_item_in_inv, game_obj) --Фикс пропадания доспавненного предмета при сейв/лоаде
		end
		num = num - num_in_box
	end
end

function fix_spawn_item_in_inv(obj, item_id, item_obj) --Фикс пропадания доспавненного предмета при сейв/лоаде
    obj:transfer_item(item_obj, obj)
end

-- удаляем объект из игры
function remove_item(remove_item)
	local sim = alife()
	if sim then
		local id = remove_item and remove_item:id()
		local obj = id and sim:object(id)
		if obj then
			sim:release(obj, true)
			return true
		end
	end
	return false
end

-- выбрасываем объект из инвентаря, применимо к ГГ
function drop_item(npc,item)
	if item then npc:drop_item(item) end
end

--убиваем непися
function make_suicide(npc)
	npc:kill(npc)
end

--узнаем отношение одного непися к другому
function get_npc_relation(obj, target)
	local rel = obj:relation(target)
	local relation
	if rel == game_object.neutral then return "neutral"
	elseif rel == game_object.friend then return "friend"
	elseif rel == game_object.enemy then return "enemy"
	end
	return false
end

--задаем отношение одного непися к другому
function set_npc_relation(obj, target, relation)
	local rel
	if relation == "neutral" then rel = game_object.neutral
	elseif relation == "friend" then rel = game_object.friend
	elseif relation == "enemy" then rel=game_object.enemy
	else return false
	end 
	sol_utils.setRelation(obj, rel, target)
	return true
end

-- узнаем группировку непися, применимо к ГГ, только ОНЛАЙН
function get_npc_community(npc)
	return npc:character_community()
end

--удаляем предмет из инвентаря по имени
function remove_item_from_inventory_by_name(remove_item_name,npc)
	return remove_item_from_inventory(npc:object(remove_item_name),npc)
end

--удаляем предмет из инвентаря
function remove_item_from_inventory(remove_item,npc)
	local sim = alife()
	if sim then
		local id = remove_item and remove_item:id()
		local obj = id and sim:object(id)
		if obj then
			sim:release(obj, true)
			return true
		end
	end
	return false
end

--очищаем инвентарь непися, можно ГГ, использует следующую фунцию для удаления предмета
function clear_npc_inventory(npc)
	npc:iterate_inventory(__del_item, npc)
end
function __del_item(npc, item)
	local section = item:section()
	if section == "bolt" or section == "device_torch" or section == "device_torch_clon" then return false end
	remove_item_from_inventory(item, npc)
end
---------------------------

--проверка запущена ли игра
function check_game()
	if level.present() and db.actor and db.actor:alive() then return true end
	return false
end

-- таблица компрессии имён
local compress_table = {}
local checked=false

-- Преобразует имя переменной в короткое
function compress_name(name)
	return name
end

--записываем переменную
function save_variable(variable_name, value)
	if value == nil then del_variable(variable_name)
	else xr_logic.pstor_store(db.actor, variable_name, value)
	--	local vn = compress_name(variable_name)
	--	xr_logic.pstor_store(db.actor, vn, value)
	end
end

--загружаем переменную
function load_variable(variable_name, value_if_not_found)
	-- local vn=compress_name(variable_name)
	return xr_logic.pstor_retrieve(db.actor, variable_name, value_if_not_found)
end

--удаляем переменную
function del_variable(variable_name)
	-- local vn = compress_name(variable_name)
	npc_id = xr_logic.get_pda_id(variable_name,"удаляем")
	if db.storage[npc_id].pstor[variable_name] ~= nil then
		db.storage[npc_id].pstor[variable_name] = nil
	end
end


--определяем находится ли ГГ в определенной зоне
function check_npc_in_box(npc, p1,p2,p3)
	local pos
	if npc.name then pos=npc:position() else pos = npc end
	if p3 == nil then
		if is_point_inside_interval(pos.x,p1.x,p2.x)
		  and is_point_inside_interval(pos.y,p1.y,p2.y)
		  and is_point_inside_interval(pos.z,p1.z,p2.z) then
			return true
		else return false
		end
	else
		local v1,v2,r,proj1,proj2,dv1,dv2
		v1, v2 = sub(p2,p1), sub(p3,p2)
		v1.y, v2.y = 0, 0
		dv1 = v1:magnitude()
		dv2 = v2:magnitude()
		v1:normalize() 
		v2:normalize()
		r = sub(pos,p1)
		local v1p = vector():set(v1.z,0,-v1.x)
		proj2 = v1p:dotproduct(r)/v1p:dotproduct(v2)
		proj1 = v1:dotproduct(r)-v1:dotproduct(v2)*proj2
		if proj1 > 0 and proj1 < dv1 and proj2 > 0 and proj2 < dv2
		  and pos.y > p1.y and pos.y < p3.y then
			return true
		else return false
		end
	end
end

function is_point_inside_interval(x,p1,p2)
	if p1 > p2 then p1, p2 = p2, p1 end
	if x > p1 and x < p2 then return true
	else return false
	end
end

function sub(v1,v2)
	local newvec = vector()
	newvec.x = v1.x-v2.x
	newvec.y = v1.y-v2.y
	newvec.z = v1.z-v2.z
	return newvec
end
----------------------------

--инвентарное название объекта
function get_inv_name(section)
	-- return system_ini():r_string(section,"inv_name")
	return getIniValueStringSimple(section,"inv_name","")
end

-- Внимание! Строки в структуре не должны содержать символов с кодами 0-31.
function pack_array_to_string(array)
	return string_format("\001%s", pack_new(array))
end


local pack_type_num=1
local pack_type_string=2
local pack_type_bool=3
local pack_type_table=4
local pack_val_endtable=5

function pack_new(tbl)
	local ret = ""
	for k,v in pairs(tbl) do
		local ty = type(k)
		if ty == "number" then ret = string_format("%s\001%s", ret, k)
		elseif ty == "string" then ret = string_format("%s\002%s", ret, k)
		end
		ty = type(v)
		if ty == "number" then ret = string_format("%s\001%s", ret, v)
		elseif ty == "string" then ret = string_format("%s\002%s", ret, v)
		elseif ty == "boolean" then
			if v then ret = string_format("%s\0031", ret)
			else ret = string_format("%s\0030", ret)
			end
		elseif ty == "table" then ret = string_format("%s\004%s\005", ret, pack_new(v))
		end
	end
	return ret
end

function parse_new(str, idx)
	local ret={}
	local idx = idx or 1
	local strlen = string_len(str)
	local key, value, vtype, idx1 --, v
	while idx <= strlen do
		vtype, idx = string_byte(string_sub(str, idx, idx)), idx + 1
		if vtype == pack_type_num then
			idx1 = idx
			while idx1 <= strlen do
				if string_byte(string_sub(str, idx1, idx1)) < 32 then break end
				idx1 = idx1 + 1
			end
			key, idx = string_sub(str, idx, idx1 - 1) + 0, idx1
		elseif vtype == pack_type_string then
			idx1 = idx
			while idx1 <= strlen do
				if string_byte(string_sub(str, idx1, idx1)) < 32 then break end
				idx1 = idx1 + 1
			end
			key, idx = string_sub(str, idx, idx1 - 1), idx1
		elseif vtype == pack_val_endtable then
			return ret, idx
		end

		vtype, idx = string_byte(string_sub(str, idx, idx)), idx + 1
		if vtype == pack_type_num then
			idx1 = idx
			while idx1 <= strlen do
				if string_byte(string_sub(str, idx1, idx1)) < 32 then break end
				idx1 = idx1 + 1
			end
			value, idx = string_sub(str, idx, idx1 - 1) + 0, idx1
		elseif vtype == pack_type_string then
			idx1 = idx
			while idx1 <= strlen do
				if string_byte(string_sub(str, idx1, idx1)) < 32 then break end
				idx1 = idx1 + 1
			end
			value, idx = string_sub(str, idx, idx1 - 1), idx1
		elseif vtype == pack_type_bool then
			value = string_sub(str,idx,idx) == "1"
			idx = idx + 1
		elseif vtype == pack_type_table then
			value, idx = parse_new(str,idx)
		end
		ret[key]=value
	end
	return ret, idx
end

function get_byte(str, idx)
	return string_byte(string_sub(str, idx, idx)), idx + 1
end

function get_string(str,idx)
	local idx1 = string_len(str) + 1
	for i = idx, string_len(str), 1 do
		if string_byte(string_sub(str,i,i)) < 32 then
			idx1 = i
			break
		end
	end
	return string_sub(str, idx, idx1 -1 ), idx1
end

function get_num(str,idx)
	local st, idx1 = get_string(str, idx)
	return st + 0, idx1
end

function get_bool(str,idx)
	local st, idx1 = get_string(str, idx)
	return st == "1", idx1
end

function unpack_array_from_string(str)
	if str ~= "" then
		if string_sub(str,1,1)~=string_char(1) then return _parse(str)	-- Старый формат упаковки
		else
			return parse_new(string_sub(str,2,-1))	-- новый формат упаковки тэгирован символом c кодом 1.
		end
	end
	return {}
end

--[[local unpack_array_from_string_cached = {}
function unpack_array_from_string(str) counterAdd("amk.unpack_array_from_string")
	if str ~= "" then
		if unpack_array_from_string_cached[str] == nil then
			if string_sub(str,1,1)~=string_char(1) then
				unpack_array_from_string_cached[str] = _parse(str)	-- Старый формат упаковки
			else
				unpack_array_from_string_cached[str] = parse_new(string_sub(str,2,-1))	-- новый формат упаковки тэгирован символом c кодом 1.
			end
		end
		return table_copy(unpack_array_from_string_cached[str])
	end
	return {}
end]]


function _assign(tbl,key,val)
	local key0 = string_match(key,'"(.*)"')
	if key0 then tbl[key0] = val
	else tbl[key+0] = val
	end
end


function _parse(str)
	local ret={}
	local str_dc = (str and string_sub(str,1,100)) or "nil" --dc--
	while (str and str ~= "") do
		local i1, i2, key = string_find(str,'(.-)=>')
		str = string_sub(str,i2+1)
		i1, i2, val = string_find(str,'"(.-)"|')
		if val and i1 == 1 then _assign(ret,key,val)	-- строка
		else
			i1, i2, val = string_find(str,'(%b{})|')
			if val and i1 == 1 then	-- таблица
				_assign(ret,key,_parse(string_sub(val,2,-2),"_parse"))
			else
				i1, i2, val  = string_find(str,'(.-)|')	-- число или булево значение
				if val=="true" then _assign(ret,key,true)
				elseif val=="false" then _assign(ret,key,false)
				else _assign(ret,key,val+0)
		end	end	end
		str=string_sub(str,i2+1)
	end
	return ret
end
---------------------------------------------
--callback section
---------------------------------------------

--колбэк на взятие предмета в инвентарь ГГ
function on_item_take(obj)
	if obj and obj:section() == "device_torch_clon" then
		local sobj = alife():object(obj:id())
		if sobj then
			alife():release(sobj, true)
		end
	end
	gps_habar.on_item_take(obj) -- Idler ++--
--	escape_dialog.have_a_art()
	flamethrower.have_a_fire_kolobok()
	flamethrower.have_a_trubki()
	flamethrower.have_a_manometr()
	flamethrower.have_a_vodko()
	flamethrower.have_a_gorelka()
	remove_spot_from_map(obj:id(),"red_location")
        remove_spot_from_map(obj:id(),"user")
	amk_mod.check_usable_item(obj)
end

--колбэк на потерю предмета из инвентаря ГГ
function on_item_drop(obj)
gps_habar.on_item_drop(obj) --idler++--
	amk_mod.check_for_af_drop(obj)
	amk_mod.check_for_item_drop(obj)
	amk_mod.check_beacon_drop(obj)
	amk_alcohol.drink_vodka(obj)	--!!! alcohol modification by Terrapack
	amkII_transmutator.amkUseTransmutator(obj)
	teleport_menu.UseTeleport(obj)
	sysadmin.UseAdminBook(obj)
	sh_remnabor.UseRemnabor(obj)
	flamethrower.have_a_fire_kolobok()
	flamethrower.have_a_trubki()
	flamethrower.have_a_manometr()
	flamethrower.have_a_vodko()
	flamethrower.have_a_gorelka()
	babah.onItemDrop(obj)
end

function on_actor_update_2()
 if amk_target then amk_target.update() end 

 local sim = alife()
 local t, n = {}, 0
 for k, v in pairs( convert_npc ) do
  if v == 2 then -- фикс от несработавшего апдейта
   v = sim:story_object( k )
   if v then sim:set_switch_online( v.id, true ) end
   n = n + 1; t[n] = k
  elseif sim:object( k ) then -- иначе все действо теряет смысл
   if v == 1 then -- Надо запихнуть в офлайн, чтобы сохранилось содержимое
    if level.object_by_id( k ) then -- онлайне, сохраняем
     sim:set_switch_online( k, false )
     sim:set_switch_offline( k, true )
    else -- уже в офлайне, разрешаем выйти
     sim:set_switch_online( k, true )
     n = n + 1; t[n] = k
    end
   elseif v == true then -- пожизненный онлайн
    sim:set_switch_online( k, true )
    sim:set_switch_offline( k, false )
    n = n + 1; t[n] = k
   elseif v == false then n = n + 1; t[n] = k 
   end
  else n = n + 1; t[n] = k
  end
 end
 for i = 1, n do convert_npc[t[n]] = nil end
end

local prev_health=0
--колбэк на апдейт ГГ (удобно для проверки условий, так как вызывается постоянно, нельзя перегружать, а то будут лаги)
function on_actor_update()
	oau_watchdog=100
	local sim = alife()
	local actor = db.actor
	local milliseconds = game_milliseconds()
	--не удалять! библиотечная конструкция
	if not timer_trigger then timer_trigger = milliseconds end
	if timer_trigger <= milliseconds then
		timer_trigger = milliseconds + 250
		check_timers()
	end
	-- user area

	oau_watchdog=90
	if game_options.gg_kick then	
		if prev_health > actor.health + 0.1 then
			level.add_pp_effector("amk_shoot.ppe", 2011, false)
			level.set_pp_effector_factor(2011, (prev_health-actor.health)*100)  
			if prev_health > actor.health + 0.2 then
				local cameffs, sounds
				if prev_health > actor.health + 0.5 then
					cameffs = {"head_shot","fusker"}
					sounds = {"pain_4","pain_1","hit_5","hit_6"}
				else
					cameffs ={"shell_shock","hit_front","hit_right","hit_back","hit_left","hit_front_left","hit_back_left","hit_front_right","hit_back_right"}
					sounds = {"pain_2","pain_3","pain_5","pain_6","pain_7","pain_8"}
				end
				level.add_cam_effector("camera_effects\\"..cameffs[math_random(#cameffs)]..".anm", 999, false, "")
				local snd_obj = xr_sound.get_safe_sound_object("actor\\"..sounds[math_random(#sounds)])
				snd_obj:play_no_feedback(actor, sound_object.s2d, 0, vector(), 1.0)
				xr_effects.actor_drop_active_item()
		end	end
		prev_health = actor.health
	end
	oau_watchdog=89
	if (amk_corpses) then for a=1, 3 do amk_corpses.update() end
	end
	oau_watchdog=86
	oAmkLauncher:UpdateFuncs()

	oau_watchdog=0
	oau_reason=""
end

function set_offline(sobj)
	local id = sobj and sobj.id
	local obj = id and level.object_by_id(id)
	if obj and npc_by_clsid[sobj:clsid()] then
		if obj:alive() then
			if not IAmAMonster[sobj:clsid()] then
				obj:stop_talk()
			end
		end
		obj:clear_animations()
	end
	switch_offline(obj)
end

function release(obj_guess)	-- удаление неписей
	local sobj = ((type(obj_guess) == "string") and alife():object(obj_guess)) or ((type(obj_guess) == "number") and alife():story_object(obj_guess))
	if sobj then
		set_offline(sobj)
		if npc_by_clsid[sobj:clsid()] then
			local strn_id = sobj.smart_terrain_id and sobj:smart_terrain_id()
			local strn = strn_id and strn_id ~= 65535 and alife():object(strn_id)
			if strn then
				strn:unregister_npc(sobj)
			end
			amk.start_timer("release_by_time", 1, sobj:name())
		else
			alife():release(sobj,true)
		end
		return true
	end
	return false
end

-----------------------

--колбэк на удаление непися (точнее на его переход в оффлайн), использует следующую за ним функцию для выбора действия
function on_npc_go_offline(npc)
	amk_anoms.unreg_in_anom_manager(npc)
	if amk_target then amk_target.net_destroy(npc) end
end

function on_monster_go_offline(npc)
--	amk_anoms.unreg_in_anom_manager(npc)
	if amk_target then amk_target.net_destroy(npc) end
end
-----------------------

--колбэк на юзание объекта
function on_use(victim, who)
	if db.actor and who and who:id()==db.actor:id() then
		amk_mod.check_usable_item(victim)
	end
end

--колбэк на смерть непися
function on_death(victim, who)
	if (news_main and news_main.on_death) then
		news_main.on_death(victim, who)
	end
	amk_anoms.unreg_in_anom_manager(victim)
	--amk_mod.generate_recipe(victim,who)
	amk_mod.firebated(victim, 1, nil, who, 14)
	amk_mod.zomby_blow(victim)
	--amk_mod.rat_tnt(victim) 
	
	--[=[if IAmAStalker[victim:clsid()]
		and victim:character_community() ~= "zombied"
		and who:id() == db.actor:id()
		and (--[[xr_wounded.is_wounded(victim) or]] victim:relation(who) == game_object.neutral or victim:relation(who) == game_object.friend)
		and victim:profile_name() ~= "ecolog_wound_bunker"
	then
		local k = victim:relation(who) == game_object.neutral and 1 or 2 -- за друга - в двое больше
		local difficulty = level.get_game_difficulty()
		who:change_character_reputation(math_floor(-(5+5*difficulty)*k))
		
		-- ухудшаем отношение тех, кто видел содеянное
		local obj
		for npcId, npc in pairs(db.storage) do
			obj = level.object_by_id(npcId)
			if obj and IAmAStalker[obj:clsid()] and npcId ~= who:id() and obj:alive() and obj:see(who) then
				-- особый случай - нельзя переводить на sol_utils
				obj:change_goodwill(math_floor(-(5+5*difficulty)*k), who)
			end
		end
		
		if k == 1 then
			relation_registry.change_community_goodwill(victim:character_community(), who:id(), math_floor(-(5+5*difficulty)))
		else
			-- ухудшаем отношение дружественных группировок в целом
			local comm = {"stalker", "monolith", "military", "killer", "ecolog", "dolg", "freedom", "bandit", "nebo", "lastday", "bandos", "voin", "green", "sniper"}
			for i = 1, #comm do
				if utils2.community_relation(comm[i], who) > 1000 then
					-- особый случай - нельзя переводить на sol_utils
					relation_registry.change_community_goodwill(comm[i], who:id(), math_floor(-(5+5*difficulty)*k))
				end
			end
		end
	end]=]
	
	if babah then
		babah.onDeath(victim, who)
	end

end

function on_npc_hit(obj, amount, local_direction, who, bone_index)
	amk_mod.firebated(obj, amount, local_direction, who, bone_index)
	if game_options.interative_music and db.actor and who and who:id()==db.actor:id() and amount>0 then
		amk_mod.calc_adrenaline("actor_hit_enemy",obj,"npc")
	end
	
	if babah then
		babah.onHit(obj, amount, local_direction, who, bone_index)
	end
end

function on_monster_hit(obj, amount, local_direction, who, bone_index)
	amk_mod.firebated(obj, amount, local_direction, who, bone_index)
	if game_options.interative_music and db.actor and who and who:id()==db.actor:id() and amount>0 then
		amk_mod.calc_adrenaline("actor_hit_enemy",obj,"monster")
	end
	
	if babah then
		babah.onHit(obj, amount, local_direction, who, bone_index)
	end

end

-- проверка на видимость производится раз в секунду
function enemy_see_actor(obj,typ)
	local onj_n10 = string_sub(obj:name(), 1, 10)
	if obj_n10 == "ferma_band" and not has_alife_info("sveeblov_ferma_have") then
		db.actor:give_info_portion("sveeblov_ferma_fail")
	end
	if game_options.interative_music then amk_mod.calc_adrenaline("enemy_see_actor", obj, typ) end
end

function actor_see_enemy(obj,typ)
	if game_options.interative_music then amk_mod.calc_adrenaline("actor_see_enemy", obj, typ) end
end

-- непись стрелял в гг
function npc_shot_actor(obj)
	if game_options.interative_music then amk_mod.calc_adrenaline("enemy_hit_actor", obj, "npc") end
end

--загружаем все переменные, которые нужно, вызывается загрузке игры, автоматически; вручную не вызывать
function on_game_load()
	-- готовим таймеры к работе с id вместо названий
	local i = 1
	for k,v in pairs(func_by_string) do
		table_insert(timers_id_name, k)
		timers_name_id[k] = i
		i = i + 1
	end

	if db.storage[db.actor:id()].pstor == nil then db.storage[db.actor:id()].pstor = {} end

	-- для совместимости оставлен старый способ с распаковкой
	local x_npc_spawner = load_variable("x_npc_spawner", "")
	if type(x_npc_spawner) == "table" then
		npc_spawner = x_npc_spawner
	else
		npc_spawner = unpack_array_from_string(x_npc_spawner)
	end

	game_options.new_game = amk.load_variable("x_first_run",true)
	amk_mod.first_run()
	convert_timers() -- переносим старые и новые таймеры в таблицу
	-- Метки теперь ставятся на серверные объекты. Обновлять их не нужно

	--user area 
	amk_mod.test_sleep_pp()
	amk_mod.check_spawn()
end

--записываем все переменные, которые нужно, вызывается присохранении игры, автоматически; вручную не вызывать
function on_game_save()
end

-- Эта функция вызывается самой первой. Онлайновые объекты недоступны! db.actor недоступен!
function on_game_start()
	ver = get_ver()
	getStartTime()
end

function getStartTime()
	local strTime = getIniValueStringSimple("alife", "start_time")
	local t = Parse_StrToTbl(strTime, ":")
	local d = Parse_StrToTbl(getIniValueStringSimple("alife", "start_date"), ".")
	StartTime = game.CTime()
	StartTime:set(d[3], d[2], 1, 0, 0, 0, 0)
	local temp = game.CTime()
	temp:setHMS(24,0,0)
	StartTime = StartTime - temp
end

--------------------- user function section---------------
function mod_call(i,...)
	-- if not amk_mod[i] then
		--
		--amk_mod.f=function() loadstring(amk.decode(c))() end
		--setfenv(amk_mod.f,amk_mod)
		--amk_mod.f()
	-- end
	amk_mod[i](...)
end

function load_table(name)
	local var = load_variable(name)
	if type(var) == "table" then
		return var
	elseif var then
		return unpack_array_from_string(var) end
	return {}
end

function save_table(name,tbl)
	save_variable(name, tbl)
end

function update_table(name,id,val)
	local tbl = load_table(name)
	tbl[id] = val
	save_table(name, tbl)
	return tbl
end

function sixbit(char)
	local byte = string_byte(char)
	local result = nil
	if (byte == 61) then result = 0
	elseif (byte == 45 or byte == 43) then result = 62
	elseif (byte == 95 or byte == 47) then result = 63
	elseif (byte <= 57) then result = byte + 4
	elseif (byte <= 90) then result = byte - 65
	elseif (byte <= 122) then result = byte - 71
	end
	return result
end

function decodeblock(block)
	local sixbits = {}
	local result = ""
	for counter=1,4 do sixbits[counter] = sixbit(string_sub(block,counter,counter)) end
	result = string_char(sixbits[1]*4 + math_floor(sixbits[2] / 16))
	if (string_sub(block,3,3) ~= "=") then
		result = result .. string_char((sixbits[2] % 16)*16 + math_floor(sixbits[3] / 4))
	end
	if (string_sub(block,4,4) ~= "=") then
		result = result .. string_char((sixbits[3] % 4) * 64 + sixbits[4])
	end
	return result
end

function decode(data)
	local result = ""
	local str={string_byte("CheckForCheat",1,1000)}
	local strl=#str
	for c=1,string_len(data),4 do result=result..decodeblock(string_sub(data,c,c+3)) end
	local result1=""
	for c=1,string_len(result),1 do
		local sl=string_byte(string_sub(result,c))
		sl=bit_xor(sl,str[1+(c-1)%strl])
		result1 = result1 .. string_char(sl)
	end
	return result1
end

function bind_lc(obj)
end

function readvu32u8(packet)
	local v={}
	local len=packet:r_s32()
	for i=1,len,1 do table_insert(v,packet:r_u8()) end
	return v
end

function readvu8u8(packet)
	local v={}
	local len=8
	for i=1,len,1 do table_insert(v,packet:r_u8()) end
	return v
end

function readvu32u16(packet)
	local v={}
	local len=packet:r_s32()
	for i=1,len,1 do table_insert(v,packet:r_u16()) end
	return v
end

function writevu32u8(pk,v)
	local len=#v
	pk:w_s32(len)
	for i=1,len,1 do pk:w_u8(v[i]) end
end

function writevu8u8(pk,v)
	local len=8 --table.getn(v)
	--pk:w_u8(len)
	for i=1,len,1 do pk:w_u8(v[i]) end
end

function writevu32u16(pk,v)
	local len=#v
	pk:w_s32(len)
	for i=1,len,1 do pk:w_u16(v[i]) end
end

function parse_object_packet(ret,stpk,updpk)
	ret.gvid=stpk:r_u16()
	ret.obf32u1=stpk:r_float()
	ret.obs32u2=stpk:r_s32()
	ret.lvid=stpk:r_s32()
	ret.oflags=stpk:r_s32()
	ret.custom=stpk:r_stringZ()
	ret.sid=stpk:r_s32()
	ret.obs32u3=stpk:r_s32()
	return ret
end

function fill_object_packet(ret,stpk,updpk)
	stpk:w_u16(ret.gvid)
	stpk:w_float(ret.obf32u1)
	stpk:w_s32(ret.obs32u2)
	stpk:w_s32(ret.lvid)
	stpk:w_s32(ret.oflags)
	stpk:w_stringZ(ret.custom)
	stpk:w_s32(ret.sid)
	stpk:w_s32(ret.obs32u3)
end


function parse_visual_packet(ret,stpk,updpk)
	ret.visual=stpk:r_stringZ()
	ret.vsu8u1=stpk:r_u8()
	return ret
end

function fill_visual_packet(ret,stpk,updpk)
	stpk:w_stringZ(ret.visual)
	stpk:w_u8(ret.vsu8u1)
end

function parse_dynamic_object_visual(ret,stpk,updpk)
	parse_object_packet(ret,stpk,updpk)
	parse_visual_packet(ret,stpk,updpk)
	return ret
end

function fill_dynamic_object_visual(ret,stpk,updpk)
	fill_object_packet(ret,stpk,updpk)
	fill_visual_packet(ret,stpk,updpk)
end

function parse_creature_packet(ret,stpk,updpk)
	parse_dynamic_object_visual(ret,stpk,updpk)
	ret.team=stpk:r_u8()
	ret.squad=stpk:r_u8()
	ret.group=stpk:r_u8()
	ret.health=stpk:r_float()
	ret.crvu32u16u1=readvu32u16(stpk)
	ret.crvu32u16u2=readvu32u16(stpk)  
	ret.killerid=stpk:r_u16()
	ret.game_death_time=readvu8u8(stpk)

	ret.updhealth=updpk:r_float()
	ret.upds32u1=updpk:r_s32()
	ret.updu8u2=updpk:r_u8()
	ret.updpos={} -- или поставить вектор? ладно потом
	ret.updpos.x=updpk:r_float()
	ret.updpos.y=updpk:r_float()
	ret.updpos.z=updpk:r_float()
	ret.updmodel=updpk:r_float()
	ret.upddir={}
	ret.upddir.x=updpk:r_float()
	ret.upddir.y=updpk:r_float()
	ret.upddir.z=updpk:r_float()
	ret.updteam=updpk:r_u8()
	ret.updsquad=updpk:r_u8()
	ret.updgroup=updpk:r_u8()  
	return ret
end

function fill_creature_packet(ret,stpk,updpk)
	fill_dynamic_object_visual(ret,stpk,updpk)
	stpk:w_u8(ret.team)
	stpk:w_u8(ret.squad)
	stpk:w_u8(ret.group)
	stpk:w_float(ret.health)
	writevu32u16(stpk,ret.crvu32u16u1)
	writevu32u16(stpk,ret.crvu32u16u2)  
	stpk:w_u16(ret.killerid)
	writevu8u8(stpk,ret.game_death_time)

	updpk:w_float(ret.updhealth)
	updpk:w_s32(ret.upds32u1)
	updpk:w_u8(ret.updu8u2)
	updpk:w_float(ret.updpos.x)
	updpk:w_float(ret.updpos.y)
	updpk:w_float(ret.updpos.z)
	updpk:w_float(ret.updmodel)
	updpk:w_float(ret.upddir.x)
	updpk:w_float(ret.upddir.y)
	updpk:w_float(ret.upddir.z)
	updpk:w_u8(ret.updteam)
	updpk:w_u8(ret.updsquad)
	updpk:w_u8(ret.updgroup)
end

function parse_monster_packet(ret,stpk,updpk)
	parse_creature_packet(ret,stpk,updpk)
	ret.baseoutr=stpk:r_stringZ()
	ret.baseinr=stpk:r_stringZ()
	ret.smtrid=stpk:r_u16()
	ret.smtrtaskactive=stpk:r_u8()
  
	ret.updu16u1=updpk:r_u16()
	ret.updu16u2=updpk:r_u16()
	ret.upds32u3=updpk:r_s32()
	ret.upds32u4=updpk:r_s32()
	return ret
end

function fill_monster_packet(ret,stpk,updpk)
	fill_creature_packet(ret,stpk,updpk)
	stpk:w_stringZ(ret.baseoutr)
	stpk:w_stringZ(ret.baseinr)
	stpk:w_u16(ret.smtrid)
	stpk:w_u8(ret.smtrtaskactive)
  
	updpk:w_u16(ret.updu16u1)
	updpk:w_u16(ret.updu16u2)
	updpk:w_s32(ret.upds32u3)
	updpk:w_s32(ret.upds32u4)
end

function parse_trader_packet(ret,stpk,updpk)
	ret.money=stpk:r_s32()
	ret.profile=stpk:r_stringZ()
	ret.infammo=stpk:r_s32()
	ret.class=stpk:r_stringZ()
	ret.communityid=stpk:r_s32()
	ret.rank=stpk:r_s32()
	ret.reputation=stpk:r_s32()
	ret.charname=stpk:r_stringZ()  
	return ret
end

function fill_trader_packet(ret,stpk,updpk)
	stpk:w_s32(ret.money)
	stpk:w_stringZ(ret.profile)
	stpk:w_s32(ret.infammo)
	stpk:w_stringZ(ret.class)
	stpk:w_s32(ret.communityid)
	stpk:w_s32(ret.rank)
	stpk:w_s32(ret.reputation)
	stpk:w_stringZ(ret.charname)
end

function parse_human_packet(ret,stpk,updpk)
	parse_trader_packet(ret,stpk,updpk)
	parse_monster_packet(ret,stpk,updpk)
	ret.huvu32u8u1=readvu32u8(stpk)
	ret.huvu32u8u2=readvu32u8(stpk)  
	return ret
end

function fill_human_packet(ret,stpk,updpk)
	fill_trader_packet(ret,stpk,updpk)
	fill_monster_packet(ret,stpk,updpk)
	writevu32u8(stpk,ret.huvu32u8u1)
	writevu32u8(stpk,ret.huvu32u8u2)
end

function parse_skeleton_packet(ret,stpk,updpk)
	ret.skeleton=stpk:r_stringZ()
	ret.skeleton_flags=stpk:r_u8()
	ret.source_id=stpk:r_u16()
  
--	ret.updsku8u1=updpk:r_u8()
	return ret
end

function fill_skeleton_packet(ret,stpk,updpk)
	stpk:w_stringZ(ret.skeleton)
	stpk:w_u8(ret.skeleton_flags)
	stpk:w_u16(ret.source_id)
  
--	updpk:w_u8(ret.updsku8u1)
end

function parse_stalker_packet(ret,stpk,updpk,size)
	parse_human_packet(ret,stpk,updpk)
	parse_skeleton_packet(ret,stpk,updpk)
	ret.hellodlg=updpk:r_stringZ()
	ret.stunk1={}
	for i=stpk:r_tell(),size-1,1 do	table_insert(ret.stunk1,stpk:r_u8()) end
	return ret
end

function fill_stalker_packet(ret,stpk,updpk)
	fill_human_packet(ret,stpk,updpk)
	fill_skeleton_packet(ret,stpk,updpk)
	updpk:w_stringZ(ret.hellodlg)
	for i,v in ipairs(ret.stunk1) do stpk:w_u8(v) end
end

function parse_se_monster_packet(ret,stpk,updpk,size)
	parse_monster_packet(ret,stpk,updpk,size)
	parse_skeleton_packet(ret,stpk,updpk,size)
	ret.spec_obj_id=stpk:r_u16()
	ret.job_online=stpk:r_u8()
	if ret.job_online>3 then
		ret.state=true
		ret.job_online=ret.job_online-4
	else ret.state=false
	end
	if ret.job_online==3 then ret.job_online_condlist=stpk:r_stringZ() end
	ret.was_in_smtr=stpk:r_u8()
	ret.stunk1={}
	for i=stpk:r_tell(),size-1,1 do table_insert(ret.stunk1,stpk:r_u8()) end
	return ret
end

function fill_se_monster_packet(ret,stpk,updpk)
	fill_monster_packet(ret,stpk,updpk)
	fill_skeleton_packet(ret,stpk,updpk)
	stpk:w_u16(ret.spec_obj_id)
	local st=0
	if ret.state then st=4 end
	stpk:w_u8(ret.job_online+st)
	if ret.job_online==3 then stpk:w_stringZ(ret.job_online_condlist) end
	stpk:w_u8(ret.was_in_smtr)
	for i,v in ipairs(ret.stunk1) do stpk:w_u8(v) end  
end

function dump_table(tbl, lvl, tbl_name)
	if not lvl or lvl < 1 then lvl = 1 end
	if tbl_name then get_console():execute(string_format("load ~~~ dump_table '%s':", tbl_name)) end
	if type(tbl) ~= "table" then
		get_console():execute("load ~~~ is not table. This is "..type(tbl))
		return
	end
	for k,v in pairs(tbl) do
		if type(v) == "table" then
			get_console():execute(string_format("load ~~~ %s%s (%s) => (%s)", string_rep(".",lvl),(type(k) == "string" or type(k) == "number" or type(k) == "boolean" or type(k) == "string" or type(k) == "nil" or type(k) == "function") and tostring(k) or "~"..type(k).."~",type(k),type(v)))
			dump_table(v,lvl + 1)
		elseif type(v) == "string" or type(v) == "number" or type(v) == "boolean" or type(v) == "function" then
			str = string_format("load ~~~ %s%s (%s) => %s (%s)", string_rep(".", lvl), (type(k) == "string" or type(k) == "number" or type(k) == "boolean" or type(k) == "string" or type(k) == "nil" or type(k) == "function") and tostring(k) or "~"..type(k).."~", type(k), (type(k) == "string" and "\"" or "")..tostring(v)..(type(k) == "string" and "\"" or ""), type(v))
			if string_len(str)>200 then str=string_sub(str,1,200) end
			get_console():execute(str)
		elseif type(v) == "userdata" then
			get_console():execute(string_format("load ~~~ %s%s => (%s)", string_rep(".",lvl),"~~~",type(v)))
		else	
			get_console():execute(string_format("load ~~~ %s%s (%s) => (%s)", string_rep(".",lvl),"~~~","неизвестно",type(v)))
		end
	end
end

-- серверный объект на входе
function read_stalker_params(sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	sobj:STATE_Write(stpk)
	sobj:UPDATE_Write(uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	local tbl=amk.parse_stalker_packet({},stpk,uppk,size)
	return tbl
end

function read_monster_params(sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	sobj:STATE_Write(stpk)
	sobj:UPDATE_Write(uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	local tbl=amk.parse_se_monster_packet({},stpk,uppk,size)
	return tbl
end

-- таблица параметров и серверный объект на входе
function write_stalker_params(tbl,sobj,noconvert)
	local stpk=net_packet()
	local uppk=net_packet()
	amk.fill_stalker_packet(tbl,stpk,uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	sobj:STATE_Read(stpk,size)
	sobj:UPDATE_Read(uppk)
	local npc=level.object_by_id(sobj.id)
	if npc and (not noconvert) then
		amk.convert_npc[sobj.id]=true
		npc:stop_talk()
		switch_offline(npc)
	end
end

function write_monster_params(tbl,sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	amk.fill_se_monster_packet(tbl,stpk,uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	sobj:STATE_Read(stpk,size)
	sobj:UPDATE_Read(uppk)
end

function get_anomaly_data(sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	sobj:STATE_Write(stpk)
	sobj:UPDATE_Write(uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
	amk.parse_shape_packet(t,stpk,uppk,size)

	t.restrictor_type = stpk:r_u8()
	
	t.max_power = stpk:r_float()
	t.owner_id = stpk:r_s32()
	t.enabled_time = stpk:r_s32()
	t.disabled_time = stpk:r_s32()
	t.start_time_shift = stpk:r_s32()
	
	t.offline_interactive_radius = stpk:r_float()
	t.artefact_spawn_count = stpk:r_u16()
	t.artefact_position_offset = stpk:r_s32()
	
	t.last_spawn_time_present = stpk:r_u8()
	
--	if stpk:r_elapsed() ~= 0 then abort("left=%d", stpk:r_elapsed()) end
	return t
end

function set_anomaly_data(t,sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	
	amk.fill_object_packet(t,stpk,uppk)
	amk.fill_shape_packet(t,stpk,uppk)
--	stpk:w_u8(t.restrictor_type)
	stpk:w_u8(2)
	
	stpk:w_float(t.max_power)
	stpk:w_s32(t.owner_id)
	stpk:w_s32(t.enabled_time)
	stpk:w_s32(t.disabled_time)
	stpk:w_s32(t.start_time_shift)
	
	stpk:w_float(t.offline_interactive_radius)
	stpk:w_u16(t.artefact_spawn_count)
	stpk:w_s32(t.artefact_position_offset)
	
	stpk:w_u8(t.last_spawn_time_present)
	
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	sobj:STATE_Read(stpk,size)
	sobj:UPDATE_Read(uppk)
end

--для правильного парсинга запрещены комментарии!!!
function parse_custom_data(str)
	local t={}
	if str then
		for section, section_data in string_gfind(str,"%s*%[([^%]]*)%]%s*([^%[%z]*)%s*") do
			section = trim(section)
			t[section]={}
			for line in string_gfind(trim(section_data), "([^\n]*)\n*") do
				if string_find(line,"=")~=nil then
					for k, v in string_gfind(line, "([^=]-)%s*=%s*(.*)") do
						k = trim(k)
						if k~=nil and k~='' and v~=nil then 
							t[section][k]=trim(v) 
						end
					end
				else
					for k, v in string_gfind(line, "(.*)") do
						k = trim(k)
						if k~=nil and k~='' then
							t[section][k]="<<no_value>>" 
						end
					end
				end
			end
		end
	end
	return t
end

function gen_custom_data(tbl)
	local str = ""
	for key, value in pairs(tbl) do
		str = str.."\n["..key.."]\n"
		for k, v in pairs(value) do
			if v~="<<no_value>>" then str=str..k.." = "..v.."\n"
			else str=str..k.."\n"
			end
		end
	end
	return str
end 

function get_lc_data(obj)
	local packet = net_packet()
	obj:STATE_Write(packet)
	local t={}
	t.game_vertex_id = packet:r_u16()
	t.distance = packet:r_float()
	t.direct_control = packet:r_s32()
	t.level_vertex_id = packet:r_s32()
	t.object_flags = packet:r_s32()
	t.custom_data = packet:r_stringZ()
	t.story_id = packet:r_s32()
	t.spawn_story_id = packet:r_s32()
	t = amk.parse_shape_packet(t,packet)
	t.restrictor_type = packet:r_u8()
	t.dest_game_vertex_id = packet:r_u16()
	t.dest_level_vertex_id = packet:r_s32()
	t.dest_position = packet:r_vec3()
	t.dest_direction = packet:r_vec3()
	t.dest_level_name = packet:r_stringZ()
	t.dest_graph_point = packet:r_stringZ()
	t.silent_mode = packet:r_u8()
	if packet:r_elapsed() ~= 0 then abort("left=%d", packet:r_elapsed()) end
	return t
end

function set_lc_data(t,obj)
	local packet = net_packet()
	obj:STATE_Write(packet)
	packet:w_begin(t.game_vertex_id)
	packet:w_float(t.distance)
	packet:w_s32(t.direct_control)
	packet:w_s32(t.level_vertex_id)
	packet:w_s32(t.object_flags)
	packet:w_stringZ(t.custom_data)
	packet:w_s32(t.story_id)
	packet:w_s32(t.spawn_story_id)
	amk.fill_shape_packet(t,packet)
	packet:w_u8(t.restrictor_type)
	packet:w_u16(t.dest_game_vertex_id)
	packet:w_s32(t.dest_level_vertex_id)
	packet:w_vec3(t.dest_position)
	packet:w_vec3(t.dest_direction)
	packet:w_stringZ(t.dest_level_name)
	packet:w_stringZ(t.dest_graph_point)
	packet:w_u8(t.silent_mode)
	packet:r_seek(0)
	obj:STATE_Read(packet, packet:w_tell())
end

function point_in_poly (pts, x,y)
	local cnt,k,j
	local ret = false
	cnt = #pts
	j = cnt
	for k = 1,cnt do
		if ((pts[k].y <=y) and (y < pts[j].y)) or ((pts[j].y <=y) and (y < pts[k].y)) then
			if (x < (pts[j].x - pts[k].x) * (y - pts[k].y) / (pts[j].y - pts[k].y) + pts[k].x) then
				ret = not ret
			end
			j = k
		end
	end
	return ret
end

function parse_object_physic_packet(ret,stpk,updpk)
	ret.physic_type=stpk:r_s32()
	ret.mass=stpk:r_float()
	ret.fixed_bones=stpk:r_stringZ()
	return ret
end

function fill_object_physic_packet(ret,stpk,updpk)
	stpk:w_s32(ret.physic_type)
	stpk:w_float(ret.mass)
	stpk:w_stringZ(ret.fixed_bones)
end

function get_breakable_data(sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	sobj:STATE_Write(stpk)
	sobj:UPDATE_Write(uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
	amk.parse_visual_packet(t,stpk,uppk,size)
	amk.parse_object_physic_packet(t,stpk,uppk,size)
	return t
end

function set_breakable_data(t,sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	amk.fill_object_packet(t,stpk,uppk)
	amk.fill_visual_packet(t,stpk,uppk)
	amk.fill_object_physic_packet(t,stpk,uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	sobj:STATE_Read(stpk,size)
	sobj:UPDATE_Read(uppk)
end

function get_spawner_data(sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	sobj:STATE_Write(stpk)
	sobj:UPDATE_Write(uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
	amk.parse_shape_packet(t,stpk,uppk,size)
	t.restrictor_type = stpk:r_u8()
	t.spawned_obj_count = stpk:r_u8()
	return t
end

function set_spawner_data(t,sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	amk.fill_object_packet(t,stpk,uppk)
	amk.fill_shape_packet(t,stpk,uppk)
	stpk:w_u8(t.restrictor_type)
	stpk:w_u8(t.spawned_obj_count)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	sobj:STATE_Read(stpk,size)
	sobj:UPDATE_Read(uppk)
end

function parse_shape_packet(t,stpk,uppk)
	local shape_count = stpk:r_u8()
	t.shapes={}
	for i=1,shape_count do
		local shape_type = stpk:r_u8()
		t.shapes[i]={}
		t.shapes[i].shtype=shape_type
		if shape_type == 0 then
			-- sphere
			t.shapes[i].center = stpk:r_vec3()
			t.shapes[i].radius = stpk:r_float()
		else
			-- box
			t.shapes[i].v1 = stpk:r_vec3()
			t.shapes[i].v2 = stpk:r_vec3()
			t.shapes[i].v3 = stpk:r_vec3()
			t.shapes[i].offset = stpk:r_vec3()
		end
	end
end

function fill_shape_packet(t,stpk,updpk)
	stpk:w_u8(#t.shapes)
	for i=1,#t.shapes do
		stpk:w_u8(t.shapes[i].shtype)
		if t.shapes[i].shtype == 0 then
			stpk:w_vec3(t.shapes[i].center)
			stpk:w_float(t.shapes[i].radius)
		else
			stpk:w_vec3(t.shapes[i].v1)
			stpk:w_vec3(t.shapes[i].v2)
			stpk:w_vec3(t.shapes[i].v3)
			stpk:w_vec3(t.shapes[i].offset)
		end
	end
end

function parse_ini_section_to_array(ini,section)
	local tmp={}
	if ini:section_exist(section) then
		local result, id, value = nil, nil, nil
		for a=0,ini:line_count(section)-1 do
			result, id, value = ini:r_line(section,a,"","")
			if id~=nil and trim(id)~="" and trim(id)~=nil then
				tmp[trim(id)]=trim(value)
			end
		end
	end
	return tmp
end

local parse_ini_section_to_array_cached = {}
function parse_ini_section_to_array_new(iniFileName, section)
	local tmp={}
	
	local iniName = iniFileName or "system_ini"
	if parse_ini_section_to_array_cached[iniName] and parse_ini_section_to_array_cached[iniName][section] then
		return table_copy(parse_ini_section_to_array_cached[iniName][section])
	end
	
	if parse_ini_section_to_array_cached[iniName] == nil then
		parse_ini_section_to_array_cached[iniName] = {}
	end
	
	if iniFileName then
		local ini = g_ini_file(iniFileName)
		if ini:section_exist(section) then
			local result, id, value = nil, nil, nil
			for a=0,ini:line_count(section)-1 do
				result, id, value = ini:r_line(section,a,"","")
				if id~=nil and trim(id)~="" and trim(id)~=nil then
					tmp[trim(id)]=trim(value)
				end
			end
		end
	else -- system_ini
		if iniSectionExistSimple(section) then
			local result, id, value = nil, nil, nil
			for a=0,iniLinesCountSimple(section)-1 do
				result, id, value = getIniLineSimple(section,a,"","")
				if id~=nil and trim(id)~="" and trim(id)~=nil then
					tmp[trim(id)]=trim(value)
				end
			end
		end
	end
	
	parse_ini_section_to_array_cached[iniName][section] = tmp
	
	return table_copy(tmp)
end


function quotemeta(str)
	return (string_gsub(s, "[%^%$%(%)%%%.%[%]%*%+%-%?]", "%%%1"))
end


function add(v1,v2)
	local nv=vector()
	nv.x=v1.x+v2.x
	nv.y=v1.y+v2.y
	nv.z=v1.z+v2.z
	return nv
end

function set_len(v,num)
	local cl = math_sqrt(v.x*v.x+v.y*v.y+v.z*v.z)
	cl = num/cl
	v.x= v.x*cl
	v.y= v.y*cl
	v.z= v.z*cl
	return v
end

function get_restrictor_data(sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	sobj:STATE_Write(stpk)
	sobj:UPDATE_Write(uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
	amk.parse_shape_packet(t,stpk,uppk,size)
	t.restrictor_type = stpk:r_u8()
	return t
end

function set_restrictor_data(t,sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	amk.fill_object_packet(t,stpk,uppk)
	amk.fill_shape_packet(t,stpk,uppk)
	stpk:w_u8(t.restrictor_type)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	sobj:STATE_Read(stpk,size)
	sobj:UPDATE_Read(uppk)
end

function get_trader_data(sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	sobj:STATE_Write(stpk)
	sobj:UPDATE_Write(uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
	amk.parse_visual_packet(t,stpk,uppk,size)
	amk.parse_trader_packet(t,stpk,uppk,size)
	return t
end

function set_trader_data(t,sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	amk.fill_object_packet(t,stpk,uppk)
	amk.fill_visual_packet(t,stpk,uppk)
	amk.fill_trader_packet(t,stpk,uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	sobj:STATE_Read(stpk,size)
	sobj:UPDATE_Read(uppk)
end


function get_invbox_data(sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	sobj:STATE_Write(stpk)
	sobj:UPDATE_Write(uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
	amk.parse_visual_packet(t,stpk,uppk,size)
	return t
end

function set_invbox_data(t,sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	amk.fill_object_packet(t,stpk,uppk)
	amk.fill_visual_packet(t,stpk,uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	sobj:STATE_Read(stpk,size)
	sobj:UPDATE_Read(uppk)
end

function readvu8uN(packet,n)
	local v={}
	for i=1,n,1 do table_insert(v,packet:r_u8()) end
	return v
end

function writevu8uN(pk,v)
	local len=#v
	--pk:w_u8(len)
	for i=1,len,1 do pk:w_u8(v[i]) end
end

function parse_item_packet(ret,stpk,updpk)
	ret.condition=stpk:r_float()
	ret.updnum_items=updpk:r_u8()
	ret.updpos={}	-- или поставить вектор? ладно потом
	ret.updpos.x=updpk:r_float()
	ret.updpos.y=updpk:r_float()
	ret.updpos.z=updpk:r_float()
	ret.updcse_alife_item__unk1_q8v4=readvu8uN(updpk,4)
	ret.updcse_alife_item__unk2_q8v3=readvu8uN(updpk,3)
	ret.updcse_alife_item__unk3_q8v3=readvu8uN(updpk,3)
	return ret
end

function fill_item_packet(ret,stpk,updpk)
	stpk:w_float(ret.condition)
	updpk:w_u8(ret.updnum_items)
	updpk:w_float(ret.updpos.x)
	updpk:w_float(ret.updpos.y)
	updpk:w_float(ret.updpos.z)
	readvu8uN(updpk,ret.updcse_alife_item__unk1_q8v4)
	readvu8uN(updpk,ret.updcse_alife_item__unk2_q8v3)
	readvu8uN(updpk,ret.updcse_alife_item__unk3_q8v3)
	return ret
end

function parse_item_ammo_packet(ret,stpk,updpk)
	ret.ammo_left=stpk:r_u16()
	ret.updammo_left=updpk:r_u16()
	return ret
end

function fill_item_ammo_packet(ret,stpk,updpk)
	stpk:w_u16(ret.ammo_left)
	updpk:w_u16(ret.updammo_left)
	return ret
end

function get_ammo_params(sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	sobj:STATE_Write(stpk)
	sobj:UPDATE_Write(uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
	amk.parse_visual_packet(t,stpk,uppk,size)
	amk.parse_item_packet(t,stpk,uppk,size)
	amk.parse_item_ammo_packet(t,stpk,uppk,size)
	return t
end

function set_ammo_data(t,sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	amk.fill_object_packet(t,stpk,uppk)
	amk.fill_visual_packet(t,stpk,uppk)
	amk.fill_item_packet(t,stpk,uppk)
	amk.fill_item_ammo_packet(t,stpk,uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	sobj:STATE_Read(stpk,size)
	sobj:UPDATE_Read(uppk)
end

function cfg_get_string(ini,sect,name,def)
	if ini and ini:line_exist(sect,name) then return ini:r_string(sect,name) end
	return def
end

function get_destroyable_data(sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	sobj:STATE_Write(stpk)
	sobj:UPDATE_Write(uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
	amk.parse_visual_packet(t,stpk,uppk,size)
	amk.parse_skeleton_packet(t,stpk,uppk,size)
	amk.parse_object_physic_packet(t,stpk,uppk,size)
	return t
end

function set_destroyable_data(t,sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	amk.fill_object_packet(t,stpk,uppk)
	amk.fill_visual_packet(t,stpk,uppk)
	amk.fill_skeleton_packet(t,stpk,uppk)
	amk.fill_object_physic_packet(t,stpk,uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	sobj:STATE_Read(stpk,size)
	sobj:UPDATE_Read(uppk)
end

function get_weapon_data(sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	sobj:STATE_Write(stpk)
	sobj:UPDATE_Write(uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
	amk.parse_visual_packet(t,stpk,uppk,size)
	amk.parse_item_packet(t,stpk,uppk,size)
	amk.parse_item_weapon_packet(t,stpk,uppk,size)
	return t
end

function set_weapon_data(t,sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	amk.fill_object_packet(t,stpk,uppk)
	amk.fill_visual_packet(t,stpk,uppk)
	amk.fill_item_packet(t,stpk,uppk)
	amk.fill_item_weapon_packet(t,stpk,uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	sobj:STATE_Read(stpk,size)
	sobj:UPDATE_Read(uppk)
end

function parse_item_weapon_packet(ret,stpk,updpk)
	ret.ammo_current = stpk:r_u16()
	ret.ammo_elapsed = stpk:r_u16()
	ret.weapon_state = stpk:r_u8()
	ret.addon_flags = stpk:r_u8()
	ret.ammo_type = stpk:r_u8()
	ret.updcondition = updpk:r_u8()
	ret.updweapon_flags = updpk:r_u8()
	ret.updammo_elapsed = updpk:r_u16()
	ret.updaddon_flags = updpk:r_u8()
	ret.updammo_type = updpk:r_u8()
	ret.updweapon_state = updpk:r_u8()
	ret.updweapon_zoom = updpk:r_u8()
	ret.updcurrent_fire_mode = updpk:r_u8()
	return ret
end

function fill_item_weapon_packet(ret,stpk,updpk)
	stpk:w_u16(ret.ammo_current)
	stpk:w_u16(ret.ammo_elapsed)
	stpk:w_u8(ret.weapon_state)
	stpk:w_u8(ret.addon_flags)
	stpk:w_u8(ret.ammo_type)
	updpk:w_u8(ret.updcondition)
	updpk:w_u8(ret.updweapon_flags)
	updpk:w_u16(ret.updammo_elapsed)
	updpk:w_u8(ret.updaddon_flags)
	updpk:w_u8(ret.updammo_type)
	updpk:w_u8(ret.updweapon_state)
	updpk:w_u8(ret.updweapon_zoom)
	updpk:w_u8(ret.updcurrent_fire_mode)
	return ret
end

function get_ver()
	return "1.0006"
end

local game_milliseconds_cached, game_seconds_cached
local game_time_ms
function game_milliseconds()
	local gt = game.time()
	if game_time_ms ~= gt then
		game_time_ms = gt
		if StartTime == nil then
			getStartTime()
			if StartTime == nil then return 0, 0 end
		end
		local gtime = game.get_game_time()
		game_seconds_cached = gtime:diffSec(StartTime)
		local y,m,d,h,min,sec,ms = gtime:get()
		game_milliseconds_cached = game_seconds_cached * 1000 + ms
	end
	return game_milliseconds_cached, game_seconds_cached
end

function game_seconds()
	local ms, s = game_milliseconds()
	return s
end

function game_minutes()
	return math_floor(game_seconds() / 60)
end

function game_hours()
	return math_floor(game_seconds() / 3600)
end

function game_days()
	return math_floor(game_seconds() / 86400)
end
